var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/merge/lib/src/index.js
var require_src = __commonJS({
  "node_modules/merge/lib/src/index.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPlainObject = exports.clone = exports.recursive = exports.merge = exports.main = void 0;
    module2.exports = exports = main;
    exports.default = main;
    function main() {
      var items = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
      }
      return merge2.apply(void 0, items);
    }
    exports.main = main;
    main.clone = clone;
    main.isPlainObject = isPlainObject;
    main.recursive = recursive;
    function merge2() {
      var items = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
      }
      return _merge(items[0] === true, false, items);
    }
    exports.merge = merge2;
    function recursive() {
      var items = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
      }
      return _merge(items[0] === true, true, items);
    }
    exports.recursive = recursive;
    function clone(input) {
      if (Array.isArray(input)) {
        var output = [];
        for (var index = 0; index < input.length; ++index)
          output.push(clone(input[index]));
        return output;
      } else if (isPlainObject(input)) {
        var output = {};
        for (var index in input)
          output[index] = clone(input[index]);
        return output;
      } else {
        return input;
      }
    }
    exports.clone = clone;
    function isPlainObject(input) {
      return input && typeof input === "object" && !Array.isArray(input);
    }
    exports.isPlainObject = isPlainObject;
    function _recursiveMerge(base, extend) {
      if (!isPlainObject(base))
        return extend;
      for (var key in extend) {
        if (key === "__proto__" || key === "constructor" || key === "prototype")
          continue;
        base[key] = isPlainObject(base[key]) && isPlainObject(extend[key]) ? _recursiveMerge(base[key], extend[key]) : extend[key];
      }
      return base;
    }
    function _merge(isClone, isRecursive, items) {
      var result;
      if (isClone || !isPlainObject(result = items.shift()))
        result = {};
      for (var index = 0; index < items.length; ++index) {
        var item = items[index];
        if (!isPlainObject(item))
          continue;
        for (var key in item) {
          if (key === "__proto__" || key === "constructor" || key === "prototype")
            continue;
          var value = isClone ? clone(item[key]) : item[key];
          result[key] = isRecursive ? _recursiveMerge(result[key], value) : value;
        }
      }
      return result;
    }
  }
});

// node_modules/pify/index.js
var require_pify = __commonJS({
  "node_modules/pify/index.js"(exports, module2) {
    "use strict";
    var processFn = (fn, options, proxy, unwrapped) => function(...arguments_) {
      const P = options.promiseModule;
      return new P((resolve, reject) => {
        if (options.multiArgs) {
          arguments_.push((...result) => {
            if (options.errorFirst) {
              if (result[0]) {
                reject(result);
              } else {
                result.shift();
                resolve(result);
              }
            } else {
              resolve(result);
            }
          });
        } else if (options.errorFirst) {
          arguments_.push((error, result) => {
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
          });
        } else {
          arguments_.push(resolve);
        }
        const self = this === proxy ? unwrapped : this;
        Reflect.apply(fn, self, arguments_);
      });
    };
    var filterCache = /* @__PURE__ */ new WeakMap();
    module2.exports = (input, options) => {
      options = __spreadValues({
        exclude: [/.+(?:Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, options);
      const objectType = typeof input;
      if (!(input !== null && (objectType === "object" || objectType === "function"))) {
        throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objectType}\``);
      }
      const filter = (target, key) => {
        let cached = filterCache.get(target);
        if (!cached) {
          cached = {};
          filterCache.set(target, cached);
        }
        if (key in cached) {
          return cached[key];
        }
        const match = (pattern) => typeof pattern === "string" || typeof key === "symbol" ? key === pattern : pattern.test(key);
        const desc = Reflect.getOwnPropertyDescriptor(target, key);
        const writableOrConfigurableOwn = desc === void 0 || desc.writable || desc.configurable;
        const included = options.include ? options.include.some(match) : !options.exclude.some(match);
        const shouldFilter = included && writableOrConfigurableOwn;
        cached[key] = shouldFilter;
        return shouldFilter;
      };
      const cache = /* @__PURE__ */ new WeakMap();
      const proxy = new Proxy(input, {
        apply(target, thisArg, args) {
          const cached = cache.get(target);
          if (cached) {
            return Reflect.apply(cached, thisArg, args);
          }
          const pified = options.excludeMain ? target : processFn(target, options, proxy, target);
          cache.set(target, pified);
          return Reflect.apply(pified, thisArg, args);
        },
        get(target, key) {
          const property = target[key];
          if (!filter(target, key) || property === Function.prototype[key]) {
            return property;
          }
          const cached = cache.get(property);
          if (cached) {
            return cached;
          }
          if (typeof property === "function") {
            const pified = processFn(property, options, proxy, target);
            cache.set(property, pified);
            return pified;
          }
          return property;
        }
      });
      return proxy;
    };
  }
});

// node_modules/minimatch/lib/path.js
var require_path = __commonJS({
  "node_modules/minimatch/lib/path.js"(exports, module2) {
    var isWindows = typeof process === "object" && process && process.platform === "win32";
    module2.exports = isWindows ? { sep: "\\" } : { sep: "/" };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m)
        return [str];
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports, module2) {
    var minimatch2 = module2.exports = (p, pattern, options = {}) => {
      assertValidPattern(pattern);
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    };
    module2.exports = minimatch2;
    var path7 = require_path();
    minimatch2.sep = path7.sep;
    var GLOBSTAR = Symbol("globstar **");
    minimatch2.GLOBSTAR = GLOBSTAR;
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var charSet = (s) => s.split("").reduce((set, c) => {
      set[c] = true;
      return set;
    }, {});
    var reSpecials = charSet("().*{}+?[]^$\\!");
    var addPatternStartSet = charSet("[.(");
    var slashSplit = /\/+/;
    minimatch2.filter = (pattern, options = {}) => (p, i, list) => minimatch2(p, pattern, options);
    var ext = (a, b = {}) => {
      const t = {};
      Object.keys(a).forEach((k) => t[k] = a[k]);
      Object.keys(b).forEach((k) => t[k] = b[k]);
      return t;
    };
    minimatch2.defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch2;
      }
      const orig = minimatch2;
      const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
      m.Minimatch = class Minimatch extends orig.Minimatch {
        constructor(pattern, options) {
          super(pattern, ext(def, options));
        }
      };
      m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
      m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
      m.defaults = (options) => orig.defaults(ext(def, options));
      m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
      m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
      m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
      return m;
    };
    minimatch2.braceExpand = (pattern, options) => braceExpand(pattern, options);
    var braceExpand = (pattern, options = {}) => {
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    };
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    var SUBPARSE = Symbol("subparse");
    minimatch2.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
    minimatch2.match = (list, pattern, options = {}) => {
      const mm = new Minimatch(pattern, options);
      list = list.filter((f) => mm.match(f));
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var Minimatch = class {
      constructor(pattern, options) {
        assertValidPattern(pattern);
        if (!options)
          options = {};
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.make();
      }
      debug() {
      }
      make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        let set = this.globSet = this.braceExpand();
        if (options.debug)
          this.debug = (...args) => console.error(...args);
        this.debug(this.pattern, set);
        set = this.globParts = set.map((s) => s.split(slashSplit));
        this.debug(this.pattern, set);
        set = set.map((s, si, set2) => s.map(this.parse, this));
        this.debug(this.pattern, set);
        set = set.filter((s) => s.indexOf(false) === -1);
        this.debug(this.pattern, set);
        this.set = set;
      }
      parseNegate() {
        if (this.options.nonegate)
          return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.substr(negateOffset);
        this.negate = negate;
      }
      matchOne(file, pattern, partial) {
        var options = this.options;
        this.debug("matchOne", { "this": this, file, pattern });
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false)
            return false;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl)
                return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern, isSub) {
        assertValidPattern(pattern);
        const options = this.options;
        if (pattern === "**") {
          if (!options.noglobstar)
            return GLOBSTAR;
          else
            pattern = "*";
        }
        if (pattern === "")
          return "";
        let re = "";
        let hasMagic = !!options.nocase;
        let escaping = false;
        const patternListStack = [];
        const negativeLists = [];
        let stateChar;
        let inClass = false;
        let reClassStart = -1;
        let classStart = -1;
        let cs;
        let pl;
        let sp;
        const patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const clearStateChar = () => {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            this.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        };
        for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern, i, re, c);
          if (escaping) {
            if (c === "/") {
              return false;
            }
            if (reSpecials[c]) {
              re += "\\";
            }
            re += c;
            escaping = false;
            continue;
          }
          switch (c) {
            case "/": {
              return false;
            }
            case "\\":
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1)
                  c = "^";
                re += c;
                continue;
              }
              this.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options.noext)
                clearStateChar();
              continue;
            case "(":
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              patternListStack.push({
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              });
              re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            case ")":
              if (inClass || !patternListStack.length) {
                re += "\\)";
                continue;
              }
              clearStateChar();
              hasMagic = true;
              pl = patternListStack.pop();
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(pl);
              }
              pl.reEnd = re.length;
              continue;
            case "|":
              if (inClass || !patternListStack.length) {
                re += "\\|";
                continue;
              }
              clearStateChar();
              re += "|";
              continue;
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                continue;
              }
              cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
              hasMagic = true;
              inClass = false;
              re += c;
              continue;
            default:
              clearStateChar();
              if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
              break;
          }
        }
        if (inClass) {
          cs = pattern.substr(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substr(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          let tail;
          tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        const addPatternStart = addPatternStartSet[re.charAt(0)];
        for (let n = negativeLists.length - 1; n > -1; n--) {
          const nl = negativeLists[n];
          const nlBefore = re.slice(0, nl.reStart);
          const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          let nlAfter = re.slice(nl.reEnd);
          const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
          const openParensBefore = nlBefore.split("(").length - 1;
          let cleanAfter = nlAfter;
          for (let i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          const dollar = nlAfter === "" && isSub !== SUBPARSE ? "$" : "";
          re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (!hasMagic) {
          return globUnescape(pattern);
        }
        const flags = options.nocase ? "i" : "";
        try {
          return Object.assign(new RegExp("^" + re + "$", flags), {
            _glob: pattern,
            _src: re
          });
        } catch (er) {
          return new RegExp("$.");
        }
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = options.nocase ? "i" : "";
        let re = set.map((pattern) => {
          pattern = pattern.map((p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src).reduce((set2, p) => {
            if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
              set2.push(p);
            }
            return set2;
          }, []);
          pattern.forEach((p, i) => {
            if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
              return;
            }
            if (i === 0) {
              if (pattern.length > 1) {
                pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
              } else {
                pattern[i] = twoStar;
              }
            } else if (i === pattern.length - 1) {
              pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
            } else {
              pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
              pattern[i + 1] = GLOBSTAR;
            }
          });
          return pattern.filter((p) => p !== GLOBSTAR).join("/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate)
          re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment)
          return false;
        if (this.empty)
          return f === "";
        if (f === "/" && partial)
          return true;
        const options = this.options;
        if (path7.sep !== "/") {
          f = f.split(path7.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename;
        for (let i = f.length - 1; i >= 0; i--) {
          filename = f[i];
          if (filename)
            break;
        }
        for (let i = 0; i < set.length; i++) {
          const pattern = set[i];
          let file = f;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate)
              return true;
            return !this.negate;
          }
        }
        if (options.flipNegate)
          return false;
        return this.negate;
      }
      static defaults(def) {
        return minimatch2.defaults(def).Minimatch;
      }
    };
    minimatch2.Minimatch = Minimatch;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  activate: () => activate
});
module.exports = __toCommonJS(src_exports);
var import_coc9 = require("coc.nvim");
var import_merge = __toESM(require_src());
var import_path6 = __toESM(require("path"));

// src/languages.ts
var import_coc2 = require("coc.nvim");

// src/util.ts
var import_pify = __toESM(require_pify());
var import_path = __toESM(require("path"));
var import_os = __toESM(require("os"));
var import_fs = __toESM(require("fs"));
var import_crypto = __toESM(require("crypto"));
var import_coc = require("coc.nvim");
var caseInsensitive = import_os.default.platform() == "win32" || import_os.default.platform() == "darwin";
var BASE64 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
function tostr(bytes) {
  let r = [];
  let i;
  for (i = 0; i < bytes.length; i++) {
    r.push(BASE64[bytes[i] % 64]);
  }
  return r.join("");
}
function uid() {
  return tostr(import_crypto.default.randomBytes(10));
}
var documentation = `# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly \${1} = new Emitter<$2>()
#		public readonly \${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt
`;
async function statAsync(filepath) {
  try {
    return await (0, import_pify.default)(import_fs.default.stat)(filepath);
  } catch (e) {
    return null;
  }
}
async function readdirAsync(filepath) {
  try {
    return await (0, import_pify.default)(import_fs.default.readdir)(filepath);
  } catch (e) {
    return null;
  }
}
function headTail(line) {
  line = line.trim();
  let ms = line.match(/^(\S+)\s+(.*)/);
  if (!ms)
    return [line, ""];
  return [ms[1], ms[2]];
}
function trimQuote(str) {
  if (str.startsWith('"') || str.startsWith("'"))
    return str.slice(1, -1);
  return str;
}
function distinct(array, keyFn) {
  if (!keyFn) {
    return array.filter((element, position) => {
      return array.indexOf(element) === position;
    });
  }
  const seen = /* @__PURE__ */ Object.create(null);
  return array.filter((elem) => {
    const key = keyFn(elem);
    if (seen[key]) {
      return false;
    }
    seen[key] = true;
    return true;
  });
}
var stringStartRe = /\\A/;
var conditionRe = /\(\?\(\w+\).+\|/;
var commentRe = /\(\?#.*?\)/;
var namedCaptureRe = /\(\?P<\w+>.*?\)/;
var namedReferenceRe = /\(\?P=(\w+)\)/;
var regex = new RegExp(`${commentRe.source}|${stringStartRe.source}|${namedCaptureRe.source}|${namedReferenceRe.source}`, "g");
function convertRegex(str) {
  if (str.indexOf("\\z") !== -1) {
    throw new Error("pattern \\z not supported");
  }
  if (str.indexOf("(?s)") !== -1) {
    throw new Error("pattern (?s) not supported");
  }
  if (str.indexOf("(?x)") !== -1) {
    throw new Error("pattern (?x) not supported");
  }
  if (str.indexOf("\n") !== -1) {
    throw new Error("multiple line pattern not supported");
  }
  if (conditionRe.test(str)) {
    throw new Error("(?id/name)yes-pattern|no-pattern not supported");
  }
  return str.replace(regex, (match, p1) => {
    if (match.startsWith("(?#"))
      return "";
    if (match == "\\A")
      return "^";
    if (match.startsWith("(?P<"))
      return "(?" + match.slice(3);
    if (match.startsWith("(?P="))
      return `\\k<${p1}>`;
    return "";
  });
}
function getRegexText(prefix) {
  if (prefix.startsWith("^"))
    prefix = prefix.slice(1);
  if (prefix.endsWith("$"))
    prefix = prefix.slice(0, -1);
  let content = prefix.replace(/\((\w+)\)\?/g, "$1").replace(/\(.*\)\??/g, "");
  content = content.replace(/\\/g, "");
  return content;
}
function getTriggerText(text, regex2) {
  if (!text || /\w/.test(text[0]) || text.length <= 2)
    return text != null ? text : "";
  if (text[0] == text[text.length - 1] && (regex2 || text.includes(" ") || text[0] == "/"))
    return text.slice(1, -1);
  return text;
}
function markdownBlock(code, filetype) {
  filetype = filetype == "javascriptreact" ? "javascript" : filetype;
  filetype = filetype == "typescriptreact" ? "typescript" : filetype;
  return "``` " + filetype + "\n" + code + "\n```";
}
async function waitDocument(doc, changedtick) {
  if (doc.changedtick >= changedtick)
    return Promise.resolve(doc.changedtick === changedtick);
  return new Promise((resolve) => {
    let timeout = setTimeout(() => {
      disposable.dispose();
      resolve(doc.changedtick == changedtick);
    }, 200);
    let disposable = doc.onDocumentChange(() => {
      clearTimeout(timeout);
      disposable.dispose();
      resolve(doc.changedtick == changedtick);
    });
  });
}
function sameFile(fullpath, other) {
  if (!fullpath || !other)
    return false;
  if (caseInsensitive)
    return fullpath.toLowerCase() === other.toLowerCase();
  return fullpath === other;
}
function characterIndex(content, byteIndex) {
  let buf = Buffer.from(content, "utf8");
  return buf.slice(0, byteIndex).toString("utf8").length;
}
function languageIdFromComments(lines) {
  for (let i = 0; i < Math.min(5, lines.length); i++) {
    let ms = lines[i].match(/^\s*\/\/\sPlace\syour\s(\w+)\sworkspace/);
    if (ms)
      return ms[1];
  }
  return void 0;
}
function omit(obj, properties) {
  let o = {};
  for (let key of Object.keys(obj)) {
    if (!properties.includes(key)) {
      o[key] = obj[key];
    }
  }
  return o;
}
function normalizeFilePath(filepath) {
  return import_coc.Uri.file(import_path.default.resolve(import_path.default.normalize(filepath))).fsPath;
}

// src/languages.ts
var codesMap = /* @__PURE__ */ new Map();
codesMap.set(1, "invalid snippet line, trigger requried.");
codesMap.set(2, 'invalid snippet option, option "$1" not supported.');
codesMap.set(3, "invalid python expression, $1");
codesMap.set(4, "invalid code interpolation, #! not supported.");
var validOptions = ["b", "i", "w", "r", "e", "A"];
var LanguageProvider = class {
  constructor(channel, trace = "error") {
    this.channel = channel;
    this.trace = trace;
    this.disposables = [];
    this.collection = import_coc2.languages.createDiagnosticCollection("snippets");
    for (let doc of import_coc2.workspace.documents) {
      if (this.shouldValidate(doc.uri)) {
        this.validate(doc.uri, doc.getDocumentContent()).catch((e) => {
          channel.appendLine(`[Error ${new Date().toLocaleTimeString()}]: ${e.message}`);
        });
      }
    }
    import_coc2.workspace.onDidOpenTextDocument(async (textDocument) => {
      let doc = import_coc2.workspace.getDocument(textDocument.uri);
      if (!this.shouldValidate(doc.uri))
        return;
      await this.validate(doc.uri, doc.getDocumentContent());
    }, null, this.disposables);
    import_coc2.workspace.onDidChangeTextDocument(async (ev) => {
      let doc = import_coc2.workspace.getDocument(ev.textDocument.uri);
      if (!doc || !this.shouldValidate(doc.uri))
        return;
      await this.validate(doc.uri, doc.getDocumentContent());
    }, null, this.disposables);
    import_coc2.workspace.onDidCloseTextDocument((e) => {
      this.collection.delete(e.uri);
    }, null, this.disposables);
  }
  shouldValidate(uri) {
    return uri.endsWith(".snippets");
  }
  async validate(uri, content) {
    let lines = content.split("\n");
    let diagnostics = [];
    let curr = 0;
    for (let line of lines) {
      if (/^snippet\s*$/.test(line)) {
        let range = import_coc2.Range.create(curr, 0, curr, line.length);
        diagnostics.push(import_coc2.Diagnostic.create(range, codesMap.get(1), import_coc2.DiagnosticSeverity.Error, 1));
        continue;
      }
      if (line.startsWith("snippet ")) {
        let content2 = headTail(line)[1];
        let ms = content2.match(/^(.+?)(?:\s+(?:"(.*?)")?(?:\s+"(.*?)")?(?:\s+(\w+))?)?$/);
        let prefix = ms[1];
        if (prefix.length > 2 && prefix[0] == prefix[prefix.length - 1] && !/\w/.test(prefix[0])) {
          prefix = prefix.slice(1, prefix.length - 1);
        }
        let option = ms[4] || "";
        let isExpression = option.indexOf("r") !== -1;
        let startCharacter = line.length - option.length;
        for (let ch of option) {
          if (validOptions.indexOf(ch) == -1) {
            let range = import_coc2.Range.create(curr, startCharacter, curr, startCharacter + 1);
            let message = codesMap.get(2).replace("$1", ch);
            diagnostics.push(import_coc2.Diagnostic.create(range, message, import_coc2.DiagnosticSeverity.Error, 2));
          }
          startCharacter = startCharacter + 1;
        }
        if (isExpression) {
          try {
            convertRegex(prefix);
          } catch (e) {
            let start = line.indexOf(prefix);
            let range = import_coc2.Range.create(curr, start, curr, start + prefix.length);
            let message = codesMap.get(3).replace("$1", e.message);
            diagnostics.push(import_coc2.Diagnostic.create(range, message, import_coc2.DiagnosticSeverity.Error, 3));
          }
        }
      } else {
        let idx = line.indexOf("`#!");
        if (idx !== -1) {
          let range = import_coc2.Range.create(curr, idx, curr, idx + 3);
          let message = codesMap.get(4);
          diagnostics.push(import_coc2.Diagnostic.create(range, message, import_coc2.DiagnosticSeverity.Error, 4));
        }
      }
      curr++;
    }
    if (this.trace == "verbose") {
      this.channel.appendLine(`[Debug ${new Date().toLocaleTimeString()}] diagnostics of ${uri} -> ${JSON.stringify(diagnostics)}`);
    }
    this.collection.set(uri, diagnostics);
  }
  provideCompletionItems(_document, position, _token, context) {
    let { input, col } = context.option;
    if (context.triggerCharacter == "$") {
      return [{
        label: "$VISUAL",
        kind: import_coc2.CompletionItemKind.Snippet,
        detail: "${VISUAL}",
        insertTextFormat: import_coc2.InsertTextFormat.Snippet,
        textEdit: {
          range: import_coc2.Range.create(position.line, position.character - 1, position.line, position.character),
          newText: "\\${VISUAL${1::default}\\}"
        }
      }];
    }
    if (col == 0 && "snippet".startsWith(input)) {
      return [{
        label: "snippet",
        kind: import_coc2.CompletionItemKind.Snippet,
        detail: "Snippet definition",
        insertTextFormat: import_coc2.InsertTextFormat.Snippet,
        insertText: 'snippet ${1:Tab_trigger} "${2:Description}" ${3:b}\n$0\nendsnippet'
      }];
    }
    return [];
  }
  async resolveCompletionItem(item) {
    let text = item.insertText || item.textEdit.newText;
    let snip = await Promise.resolve(import_coc2.snippetManager.resolveSnippet(text));
    item.documentation = {
      kind: "markdown",
      value: markdownBlock(snip.toString(), "snippets")
    };
    return item;
  }
};
function registerLanguageProvider(subscriptions, channel, configuration) {
  let trace = configuration.get("trace", "error");
  let languageProvider = new LanguageProvider(channel, trace);
  subscriptions.push(import_coc2.languages.registerCompletionItemProvider("snippets-source", configuration.get("shortcut", "S"), ["snippets"], languageProvider, ["$"], configuration.get("priority", 90)));
}

// src/list/snippet.ts
var import_coc3 = require("coc.nvim");
var import_os2 = __toESM(require("os"));
var SnippetsList = class extends import_coc3.BasicList {
  constructor(nvim, manager) {
    super(nvim);
    this.manager = manager;
    this.name = "snippets";
    this.description = "snippets list";
    this.addLocationActions();
  }
  async loadItems(context) {
    let { window: window5 } = context;
    let valid = await window5.valid;
    if (!valid)
      return;
    let buf = await window5.buffer;
    let doc = import_coc3.workspace.getDocument(buf.id);
    if (!doc)
      return [];
    let snippets = this.manager.getSnippets(doc.filetype);
    let res = [];
    for (let snip of snippets) {
      let pos = import_coc3.Position.create(snip.lnum, 0);
      let location = import_coc3.Location.create(import_coc3.Uri.file(snip.filepath).toString(), import_coc3.Range.create(pos, import_coc3.Position.create(snip.lnum, 1)));
      let prefix = snip.prefix;
      if (prefix.length < 20) {
        prefix = `${prefix}${" ".repeat(20 - prefix.length)}`;
      }
      res.push({
        label: `${prefix}	${snip.description}	${snip.filepath.replace(import_os2.default.homedir(), "~")}`,
        filterText: `${snip.prefix} ${snip.description}`,
        location,
        data: { prefix: snip.prefix }
      });
    }
    return res;
  }
  async doHighlight() {
    let { nvim } = import_coc3.workspace;
    nvim.pauseNotification();
    nvim.command("syntax match CocSnippetsPrefix /\\v^[^\\t]+/ contained containedin=CocSnippetsLine", true);
    nvim.command("syntax match CocSnippetsFile /\\v\\t\\S+$/ contained containedin=CocSnippetsLine", true);
    nvim.command("highlight default link CocSnippetsPrefix Identifier", true);
    nvim.command("highlight default link CocSnippetsFile Comment", true);
    void nvim.resumeNotification(false, true);
  }
};

// src/massCodeProvider.ts
var import_coc4 = require("coc.nvim");
var import_http = __toESM(require("http"));

// src/baseProvider.ts
var import_minimatch = __toESM(require_minimatch());
var BaseProvider = class {
  constructor(config, channel) {
    this.config = config;
    this.channel = channel;
  }
  async checkContext(_context) {
    return true;
  }
  isIgnored(filepath) {
    let ignored = false;
    let { excludes } = this.config;
    for (let p of excludes) {
      if ((0, import_minimatch.default)(filepath, p, { dot: true })) {
        ignored = true;
        this.info(`File ignored by excludePatterns: ${filepath}`);
        break;
      }
    }
    return ignored;
  }
  getExtendsFiletypes(filetype, exists = /* @__PURE__ */ new Set()) {
    if (exists.has(filetype))
      return [];
    let extend = this.config.extends ? this.config.extends[filetype] : null;
    exists.add(filetype);
    if (!extend || extend.length == 0)
      return [];
    return extend.reduce((arr, curr) => {
      return arr.concat([curr], this.getExtendsFiletypes(curr, exists));
    }, []);
  }
  getFiletypes(filetype) {
    let filetypes = [filetype];
    if (filetype.indexOf(".") !== -1) {
      filetypes.push(...filetype.split("."));
    }
    if (filetype == "latex")
      filetypes.push("tex");
    if (filetype == "javascriptreact" && !filetypes.includes("javascript")) {
      filetypes.push("javascript");
    }
    if (filetype == "typescriptreact" && !filetypes.includes("typescript")) {
      filetypes.push("typescript");
    }
    let extendFiletypes = filetypes.reduce((arr, curr) => {
      return arr.concat(this.getExtendsFiletypes(curr));
    }, []);
    filetypes.push(...extendFiletypes);
    return distinct(filetypes);
  }
  message(kind, msg, data) {
    let str = new Date().toISOString().replace(/^.*T/, "").replace(/Z$/, "");
    this.channel.appendLine(`[${kind} - ${str}] ${msg}`);
    if (data !== void 0)
      this.channel.appendLine(JSON.stringify(data, null, 2));
  }
  info(msg, data) {
    this.message("Info ", msg, data);
  }
  error(msg, data) {
    this.message("Error", msg, data);
  }
  trace(msg, data) {
    if (this.config.trace) {
      this.message("Trace", msg, data);
    }
  }
};

// src/massCodeProvider.ts
function getMatched(snippet, line) {
  let { prefix, regex: regex2 } = snippet;
  if (regex2) {
    let ms = line.match(regex2);
    if (!ms)
      return void 0;
    return ms[0];
  }
  if (!line.endsWith(prefix))
    return void 0;
  return prefix;
}
var unknownFileTypes = ["typescriptreact", "javascriptreact"];
var MassCodeProvider = class extends BaseProvider {
  constructor(channel, config) {
    super(config, channel);
    this.config = config;
    this.massCodeItems = [];
  }
  async init() {
    this.baseHttpConfig = { host: this.config.host, port: this.config.port, method: "GET" };
    this.massCodeItems = await this.loadAllSnippets();
  }
  async getSnippetFiles(filetype) {
    let filetypes = this.getFiletypes(filetype);
    filetypes.push("all");
    let res = [];
    for (let s of this.massCodeItems) {
      for (let c of s.content) {
        if (filetypes.includes(c.language)) {
          res.push(s.folderId);
        }
      }
    }
    return res;
  }
  async getTriggerSnippets(document, position, autoTrigger) {
    if (autoTrigger)
      return [];
    const line = document.getline(position.line);
    if (line.length == 0)
      return [];
    const snippets = this.getSnippets(document.filetype).filter((s) => {
      if (autoTrigger && !s.autoTrigger)
        return false;
      let match = getMatched(s, line);
      if (match == null)
        return false;
      if (s.triggerKind == 3 /* InWord */)
        return true;
      let pre = line.slice(0, line.length - match.length);
      if (s.triggerKind == 1 /* LineBegin */)
        return pre.trim() == "";
      if (s.triggerKind == 0 /* SpaceBefore */)
        return pre.length == 0 || /\s$/.test(pre);
      if (s.triggerKind == 2 /* WordBoundary */)
        return pre.length == 0 || !document.isWord(pre[pre.length - 1]);
      return false;
    });
    snippets.sort((a, b) => {
      if (a.context && !b.context)
        return -1;
      if (b.context && !a.context)
        return 1;
      return 0;
    });
    let edits = [];
    let hasContext = false;
    for (let s of snippets) {
      let character;
      if (s.context) {
        let valid = await this.checkContext(s.context);
        if (!valid)
          continue;
        hasContext = true;
      } else if (hasContext) {
        break;
      }
      if (s.regex == null) {
        character = position.character - s.prefix.length;
      } else {
        let len = line.match(s.regex)[0].length;
        character = position.character - len;
      }
      let range = import_coc4.Range.create(position.line, character, position.line, position.character);
      edits.push({
        range,
        newText: s.body,
        prefix: s.prefix,
        description: s.description,
        location: s.filepath,
        priority: s.priority,
        regex: s.originRegex,
        context: s.context
      });
    }
    return edits;
  }
  async loadAllSnippets() {
    this.info(`Loading all massCode snippets from http://${this.config.host}:${this.config.port}/snippets/embed-folder`);
    const options = __spreadProps(__spreadValues({}, this.baseHttpConfig), {
      path: "/snippets/embed-folder"
    });
    const onEnd = (resolve, reject, body) => {
      try {
        resolve(JSON.parse(Buffer.concat(body).toString()));
      } catch (e) {
        reject(e);
      }
    };
    return promisifyHttpRequest(options, onEnd);
  }
  mapItems() {
    let counter = 0;
    return this.massCodeItems.filter((item) => !item.isDeleted).flatMap((item) => {
      return item.content.map((content) => {
        const snippet = {
          filepath: item.id,
          lnum: counter,
          body: content.value,
          prefix: item.name,
          description: item.name,
          triggerKind: 2 /* WordBoundary */,
          filetype: content.language
        };
        counter = counter + 1;
        return snippet;
      });
    });
  }
  getSnippets(filetype) {
    return this.mapItems().filter((snippet) => this.getFiletypes(filetype).includes(snippet.filetype));
  }
  async createSnippet(text) {
    const doc = await import_coc4.workspace.document;
    const name = await import_coc4.window.requestInput("Snippet Name");
    if (!name) {
      return Promise.resolve();
    }
    await this.init();
    const filetypes = this.getFiletypes(doc.filetype).filter((filetype) => {
      return !unknownFileTypes.includes(filetype);
    });
    if (this.mapItems().some((item) => item.prefix === name && filetypes.includes(item.filetype))) {
      import_coc4.window.showMessage(`Snippet with name ${name} for this filetype already exists`);
      return Promise.resolve();
    }
    const config = __spreadProps(__spreadValues({}, this.baseHttpConfig), {
      method: "POST",
      path: "/snippets/create"
    });
    const onEnd = (resolve, reject, body) => {
      try {
        resolve(body);
      } catch (e) {
        reject(e);
      }
    };
    const requests = filetypes.map((filetype) => {
      const newIndex = Math.max(...this.mapItems().map((item) => item.lnum)) + 1;
      const newSnippet = {
        content: [{
          label: "Fragment 1",
          value: text.replace(/\n$/, ""),
          language: filetype
        }],
        createdAt: Date.now(),
        folderId: `${newIndex}`,
        id: `${newIndex}`,
        isDeleted: false,
        isFavorites: false,
        name,
        updatedAt: Date.now()
      };
      this.massCodeItems.push(newSnippet);
      return promisifyHttpRequest(config, onEnd, JSON.stringify(newSnippet));
    });
    await Promise.all(requests);
  }
};
async function promisifyHttpRequest(config, onEnd, body) {
  const options = __spreadValues({}, config);
  if (options.method === "POST" && body.length) {
    options.headers = {
      "Content-Type": "application/json",
      "Content-Length": body.length
    };
  }
  return new Promise(function(resolve, reject) {
    const req = import_http.default.request(options, function(res) {
      if (res.statusCode < 200 || res.statusCode >= 300) {
        return reject(new Error("statusCode=" + res.statusCode));
      }
      const body2 = [];
      res.on("data", function(chunk) {
        body2.push(chunk);
      });
      res.on("end", function() {
        onEnd(resolve, reject, body2);
      });
    });
    req.on("error", function(err) {
      if (err.code === "ECONNREFUSED") {
        import_coc4.window.showMessage("massCode is not running");
      } else {
        reject(err);
      }
    });
    if (body) {
      req.write(body);
    }
    req.end();
  });
}

// src/provider.ts
var import_coc5 = require("coc.nvim");
var import_path2 = __toESM(require("path"));
var ProviderManager = class {
  constructor(channel, subscriptions) {
    this.channel = channel;
    this.providers = /* @__PURE__ */ new Map();
    subscriptions.push(import_coc5.Disposable.create(() => {
      this.providers.clear();
    }));
  }
  regist(provider, name) {
    this.providers.set(name, provider);
    return import_coc5.Disposable.create(() => {
      this.providers.delete(name);
    });
  }
  get hasProvider() {
    return this.providers.size > 0;
  }
  async init() {
    let providers = Array.from(this.providers.values());
    await Promise.all(providers.map((provider) => {
      return provider.init();
    })).catch((e) => {
      import_coc5.workspace.nvim.echoError(e);
      this.appendError("init", e);
    });
  }
  getSnippets(filetype) {
    let names = Array.from(this.providers.keys());
    let list = [];
    for (let name of names) {
      let provider = this.providers.get(name);
      try {
        let snippets = provider.getSnippets(filetype);
        snippets.map((s) => s.provider = name);
        list.push(...snippets);
      } catch (e) {
        this.appendError(`getSnippets of ${name}`, e);
      }
    }
    list.sort((a, b) => {
      if (a.filetype != b.filetype && (a.filetype == filetype || b.filetype == filetype)) {
        return a.filetype == filetype ? -1 : 1;
      }
      if (a.priority != b.priority) {
        return b.priority - a.priority;
      }
      if (a.filepath != b.filepath) {
        return b.filepath > a.filepath ? 1 : -1;
      }
      return a.lnum - b.lnum;
    });
    return list;
  }
  async getSnippetFiles(filetype) {
    let files = [];
    for (let [name, provider] of this.providers.entries()) {
      try {
        let res = await provider.getSnippetFiles(filetype);
        files = files.concat(res);
      } catch (e) {
        this.appendError(`getSnippetFiles of ${name}`, e);
      }
    }
    return files;
  }
  async getTriggerSnippets(bufnr, autoTrigger = false, position) {
    let doc = import_coc5.workspace.getDocument(bufnr);
    if (!doc)
      return [];
    if (!position)
      position = await import_coc5.window.getCursorPosition();
    let names = Array.from(this.providers.keys());
    let list = [];
    for (let name of names) {
      let provider = this.providers.get(name);
      try {
        let items = await provider.getTriggerSnippets(doc, position, autoTrigger);
        for (let item of items) {
          list.push(Object.assign({ source: name }, item));
        }
      } catch (e) {
        this.appendError(`get trigger snippets of ${name}`, e);
      }
    }
    list.sort((a, b) => b.priority - a.priority);
    if (list.length > 1) {
      let priority = list[0].priority;
      list = list.filter((o) => o.priority == priority);
    }
    return list;
  }
  appendError(name, e) {
    this.channel.appendLine(`[Error ${new Date().toLocaleTimeString()}] Error on ${name}: ${typeof e === "string" ? e : e.message}`);
    if (e instanceof Error) {
      this.channel.appendLine(e.stack);
    }
  }
  async provideCompletionItems(document, position, _token, context) {
    let doc = import_coc5.workspace.getDocument(document.uri);
    if (!doc)
      return [];
    let snippets = this.getSnippets(doc.filetype);
    let currline = doc.getline(position.line, true);
    let { input, col, line, colnr } = context.option;
    let character = characterIndex(line, col);
    let before_content = currline.slice(0, character);
    let after = line.slice(characterIndex(line, colnr - 1));
    let res = [];
    let noneWords = before_content.endsWith(" ") ? "" : before_content.match(/\W*$/)[0];
    for (let snip of snippets) {
      if (snip.context || snip.prefix === "")
        continue;
      if (input.length == 0 && (!snip.special || !before_content.endsWith(snip.special)))
        continue;
      let contentBefore = before_content;
      let head = this.getPrefixHead(doc, snip.prefix);
      let ultisnip = snip.provider == "ultisnips" || snip.provider == "snipmate";
      let startCharacter = character;
      let item = {
        label: snip.prefix,
        kind: import_coc5.CompletionItemKind.Snippet,
        filterText: snip.prefix,
        detail: snip.description,
        insertTextFormat: import_coc5.InsertTextFormat.Snippet
      };
      if (noneWords && snip.special) {
        if (noneWords.endsWith(snip.special)) {
          let len = snip.special.length;
          item.filterText = item.filterText.slice(len);
          startCharacter = character - len;
          contentBefore = contentBefore.slice(0, -len);
        } else {
          continue;
        }
      }
      item.data = {
        snip,
        provider: snip.provider,
        filepath: `${import_path2.default.basename(snip.filepath)}:${snip.lnum}`
      };
      if (ultisnip) {
        item.data.ultisnip = {
          context: snip.context,
          regex: snip.originRegex,
          range: import_coc5.Range.create(position.line, startCharacter, position.line, character + snip.prefix.length),
          line: before_content + snip.prefix + after
        };
      }
      if (snip.regex) {
        if (!input.length || snip.prefix && input[0] != snip.prefix[0])
          continue;
        let content = before_content + snip.prefix;
        let ms = content.match(snip.regex);
        if (!ms)
          continue;
      } else if (head && before_content.endsWith(head)) {
        contentBefore = before_content.slice(0, -head.length);
        Object.assign(item, {
          textEdit: {
            range: import_coc5.Range.create({ line: position.line, character: startCharacter }, position),
            newText: snip.prefix
          }
        });
      } else if (input.length == 0) {
        Object.assign(item, {
          preselect: true,
          textEdit: {
            range: import_coc5.Range.create({ line: position.line, character: startCharacter }, position),
            newText: snip.prefix
          }
        });
      }
      if (snip.triggerKind == 1 /* LineBegin */ && contentBefore.trim().length)
        continue;
      if (snip.triggerKind == 0 /* SpaceBefore */) {
        if (contentBefore.length && !/\s/.test(contentBefore[contentBefore.length - 1])) {
          continue;
        }
      }
      if (!item.textEdit) {
        item.textEdit = {
          range: import_coc5.Range.create({ line: position.line, character: startCharacter }, position),
          newText: snip.prefix
        };
      }
      res.push(item);
    }
    return res;
  }
  async resolveCompletionItem(item) {
    let provider = this.providers.get(item.data.provider);
    if (provider) {
      let doc = import_coc5.workspace.getDocument(import_coc5.workspace.bufnr);
      let filetype = doc ? doc.filetype : void 0;
      let insertSnippet = item.data.snip.body;
      if (import_coc5.snippetManager && insertSnippet) {
        if (typeof provider.resolveSnippetBody === "function") {
          insertSnippet = await Promise.resolve(provider.resolveSnippetBody(insertSnippet));
        }
        item.textEdit.newText = insertSnippet;
        let resolved = await import_coc5.snippetManager.resolveSnippet(insertSnippet, item.data.ultisnip);
        if (typeof resolved !== "string") {
          import_coc5.window.showErrorMessage(`Please upgrade your coc.nvim to use coc-snippets`);
          return;
        }
        let ms = filetype == null ? void 0 : filetype.match(/^\w+/);
        let block = markdownBlock(resolved, ms == null ? "txt" : ms[0]);
        item.documentation = {
          kind: "markdown",
          value: block + (item.data.filepath ? `
${item.data.filepath}` : "")
        };
      }
    }
    return item;
  }
  getPrefixHead(doc, prefix) {
    let res = 0;
    for (let idx = prefix.length - 1; idx >= 0; idx--) {
      if (!doc.isWord(prefix[idx])) {
        res = idx;
        break;
      }
    }
    return res == 0 ? "" : prefix.slice(0, res + 1);
  }
};

// src/snipmateProvider.ts
var import_coc6 = require("coc.nvim");
var import_fs2 = __toESM(require("fs"));
var import_path3 = __toESM(require("path"));
var import_readline = __toESM(require("readline"));
function convertBody(body) {
  return body.replace(/`(.*?)(?<!\\)`/g, (_, p1) => {
    if (p1.startsWith("Filename(")) {
      p1 = p1.replace(/^Filename/, "vim_snippets#Filename");
    }
    return "`!v " + p1 + "`";
  });
}
var SnipmateProvider = class extends BaseProvider {
  constructor(channel, config, subscriptions) {
    super(config, channel);
    this.config = config;
    this.subscriptions = subscriptions;
    this.fileItems = [];
    this.snippetFiles = [];
    import_coc6.workspace.onDidSaveTextDocument(async (doc) => {
      let uri = import_coc6.Uri.parse(doc.uri);
      if (uri.scheme != "file")
        return;
      let filepath = uri.fsPath;
      if (!import_fs2.default.existsSync(filepath))
        return;
      let idx = this.snippetFiles.findIndex((s) => sameFile(s.filepath, filepath));
      if (idx !== -1) {
        let filetype = this.snippetFiles[idx].filetype;
        this.snippetFiles.splice(idx, 1);
        await this.loadSnippetsFromFile(filetype, filepath);
      }
    }, null, this.subscriptions);
  }
  async init() {
    let { nvim } = import_coc6.workspace;
    let author = await nvim.getVar("snips_author");
    if (!author)
      await nvim.setVar("snips_author", this.config.author);
    this.fileItems = await this.loadAllSnippetFiles();
    import_coc6.workspace.onDidRuntimePathChange(async (e) => {
      for (let rtp of e) {
        let items = await this.getSnippetFileItems(import_path3.default.join(rtp, "snippets"));
        if (items == null ? void 0 : items.length) {
          this.fileItems.push(...items);
          for (let item of items) {
            if (import_coc6.workspace.filetypes.has(item.filetype)) {
              await this.loadSnippetsFromFile(item.filetype, item.filepath);
            }
          }
        }
      }
    }, null, this.subscriptions);
    for (let filetype of import_coc6.workspace.filetypes) {
      await this.loadByFiletype(filetype);
    }
    import_coc6.workspace.onDidOpenTextDocument(async (e) => {
      let doc = import_coc6.workspace.getDocument(e.bufnr);
      await this.loadByFiletype(doc.filetype);
    }, null, this.subscriptions);
  }
  async loadByFiletype(filetype) {
    let filetypes = filetype ? this.getFiletypes(filetype) : [];
    filetypes.push("_");
    for (let item of this.fileItems) {
      if (!filetypes.includes(item.filetype))
        continue;
      await this.loadSnippetsFromFile(item.filetype, item.filepath);
    }
  }
  async loadSnippetsFromFile(filetype, filepath) {
    let idx = this.snippetFiles.findIndex((o) => sameFile(o.filepath, filepath));
    if (idx !== -1)
      return;
    idx = this.fileItems.findIndex((o) => o.filepath == filepath);
    if (idx !== -1)
      this.fileItems.splice(idx, 1);
    if (this.isIgnored(filepath))
      return;
    let res = await this.parseSnippetsFile(filetype, filepath);
    this.snippetFiles.push({ filepath, filetype, snippets: res.snippets });
    this.info(`Loaded ${res.snippets.length} ${filetype} snipmate snippets from: ${filepath}`);
    if (res.extends.length) {
      let fts = res.extends;
      let curr = this.config.extends[filetype] || [];
      for (let ft of fts) {
        await this.loadByFiletype(ft);
        if (!curr.includes(ft)) {
          curr.push(ft);
        }
      }
      this.config.extends[filetype] = curr;
    }
  }
  parseSnippetsFile(filetype, filepath) {
    let res = [];
    let extendsFiletypes = [];
    const rl = import_readline.default.createInterface({
      input: import_fs2.default.createReadStream(filepath, "utf8"),
      crlfDelay: Infinity
    });
    let lnum = 0;
    let lines = [];
    let prefix = "";
    let description = "";
    rl.on("line", (line) => {
      lnum += 1;
      if (line.startsWith("#"))
        return;
      if (/^extends\s/.test(line)) {
        let ft = line.replace(/^extends\s+/, "");
        if (ft)
          extendsFiletypes.push(ft);
        return;
      }
      if (line.startsWith("snippet")) {
        line = line.replace(/\s*$/, "");
        if (lines.length && prefix) {
          let body = lines.join("\n").replace(/\s+$/, "");
          res.push({
            filepath,
            filetype,
            lnum: lnum - lines.length - 1,
            body: convertBody(body),
            prefix,
            description,
            triggerKind: 0 /* SpaceBefore */,
            provider: "snipmate"
          });
          lines = [];
        }
        let ms = line.match(/^snippet\s+(\S+)(?:\s(.+))?$/);
        if (!ms) {
          prefix = "";
          this.error(`Broken line on ${filepath}:${lnum}`);
          return;
        }
        prefix = ms[1];
        description = ms[2] || "";
        return;
      }
      if (prefix) {
        if (line.startsWith("	")) {
          lines.push(line.slice(1));
        } else {
          lines.push(line);
        }
      }
    });
    return new Promise((resolve) => {
      rl.on("close", async () => {
        if (lines.length) {
          let body = lines.join("\n").replace(/\s+$/, "");
          res.push({
            filepath,
            lnum: lnum - lines.length - 1,
            filetype,
            body: convertBody(body),
            prefix,
            description,
            triggerKind: 0 /* SpaceBefore */
          });
        }
        this.trace("snipmate snippets", res);
        resolve({ snippets: res, extends: extendsFiletypes });
      });
    });
  }
  async getTriggerSnippets(document, position, autoTrigger) {
    if (autoTrigger)
      return [];
    let snippets = this.getSnippets(document.filetype);
    let line = document.getline(position.line);
    line = line.slice(0, position.character);
    if (!line || line[line.length - 1] == " ")
      return [];
    snippets = snippets.filter((s) => {
      let { prefix } = s;
      if (!line.endsWith(prefix))
        return false;
      let pre = line.slice(0, line.length - prefix.length);
      return pre.length == 0 || /\s/.test(pre[pre.length - 1]);
    });
    let edits = [];
    for (let s of snippets) {
      let character = position.character - s.prefix.length;
      let range = import_coc6.Range.create(position.line, character, position.line, position.character);
      edits.push({
        prefix: s.prefix,
        description: s.description,
        location: s.filepath,
        range,
        newText: s.body,
        priority: -1
      });
    }
    return edits;
  }
  async getSnippetFiles(filetype) {
    let filetypes = filetype ? this.getFiletypes(filetype) : [];
    filetypes.push("_");
    let res = [];
    for (let s of this.snippetFiles) {
      if (filetypes.indexOf(s.filetype) !== -1) {
        res.push(s.filepath);
      }
    }
    return res;
  }
  getSnippets(filetype) {
    let filetypes = this.getFiletypes(filetype);
    filetypes.push("_");
    let snippetFiles = this.snippetFiles.filter((o) => filetypes.includes(o.filetype));
    let result = [];
    snippetFiles.sort((a, b) => {
      if (a.filetype == b.filetype)
        return 1;
      if (a.filetype == filetype)
        return -1;
      return 1;
    });
    for (let file of snippetFiles) {
      let { snippets } = file;
      for (let snip of snippets) {
        result.push(snip);
      }
    }
    return result;
  }
  async loadAllSnippetFiles() {
    let { env } = import_coc6.workspace;
    let rtps = env.runtimepath.split(",");
    let res = [];
    for (let rtp of rtps) {
      let items = await this.getSnippetFileItems(import_path3.default.join(rtp, "snippets"));
      res.push(...items);
    }
    return res;
  }
  async getSnippetFileItems(directory) {
    let res = [];
    let stat = await statAsync(directory);
    if (stat && stat.isDirectory()) {
      let files = await readdirAsync(directory);
      if (files.length) {
        for (let f of files) {
          let file = import_path3.default.join(directory, f);
          if (file.endsWith(".snippets")) {
            let basename = import_path3.default.basename(f, ".snippets");
            let filetype = basename.split("-", 2)[0];
            res.push({ filepath: file, directory, filetype });
          } else {
            let stat2 = await statAsync(file);
            if (stat2 && stat2.isDirectory()) {
              let files2 = await readdirAsync(file);
              for (let filename of files2) {
                if (filename.endsWith(".snippets")) {
                  res.push({ filepath: import_path3.default.join(file, filename), directory, filetype: f });
                }
              }
            }
          }
        }
      }
    }
    return res;
  }
};

// src/textmateProvider.ts
var import_coc7 = require("coc.nvim");
var import_fs3 = __toESM(require("fs"));

// node_modules/jsonc-parser/lib/esm/impl/scanner.js
function createScanner(text, ignoreTrivia) {
  if (ignoreTrivia === void 0) {
    ignoreTrivia = false;
  }
  var len = text.length;
  var pos = 0, value = "", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;
  function scanHexDigits(count, exact) {
    var digits = 0;
    var value2 = 0;
    while (digits < count || !exact) {
      var ch = text.charCodeAt(pos);
      if (ch >= 48 && ch <= 57) {
        value2 = value2 * 16 + ch - 48;
      } else if (ch >= 65 && ch <= 70) {
        value2 = value2 * 16 + ch - 65 + 10;
      } else if (ch >= 97 && ch <= 102) {
        value2 = value2 * 16 + ch - 97 + 10;
      } else {
        break;
      }
      pos++;
      digits++;
    }
    if (digits < count) {
      value2 = -1;
    }
    return value2;
  }
  function setPosition(newPosition) {
    pos = newPosition;
    value = "";
    tokenOffset = 0;
    token = 16;
    scanError = 0;
  }
  function scanNumber() {
    var start = pos;
    if (text.charCodeAt(pos) === 48) {
      pos++;
    } else {
      pos++;
      while (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
      }
    }
    if (pos < text.length && text.charCodeAt(pos) === 46) {
      pos++;
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
      } else {
        scanError = 3;
        return text.substring(start, pos);
      }
    }
    var end = pos;
    if (pos < text.length && (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101)) {
      pos++;
      if (pos < text.length && text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45) {
        pos++;
      }
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
        end = pos;
      } else {
        scanError = 3;
      }
    }
    return text.substring(start, end);
  }
  function scanString() {
    var result = "", start = pos;
    while (true) {
      if (pos >= len) {
        result += text.substring(start, pos);
        scanError = 2;
        break;
      }
      var ch = text.charCodeAt(pos);
      if (ch === 34) {
        result += text.substring(start, pos);
        pos++;
        break;
      }
      if (ch === 92) {
        result += text.substring(start, pos);
        pos++;
        if (pos >= len) {
          scanError = 2;
          break;
        }
        var ch2 = text.charCodeAt(pos++);
        switch (ch2) {
          case 34:
            result += '"';
            break;
          case 92:
            result += "\\";
            break;
          case 47:
            result += "/";
            break;
          case 98:
            result += "\b";
            break;
          case 102:
            result += "\f";
            break;
          case 110:
            result += "\n";
            break;
          case 114:
            result += "\r";
            break;
          case 116:
            result += "	";
            break;
          case 117:
            var ch3 = scanHexDigits(4, true);
            if (ch3 >= 0) {
              result += String.fromCharCode(ch3);
            } else {
              scanError = 4;
            }
            break;
          default:
            scanError = 5;
        }
        start = pos;
        continue;
      }
      if (ch >= 0 && ch <= 31) {
        if (isLineBreak(ch)) {
          result += text.substring(start, pos);
          scanError = 2;
          break;
        } else {
          scanError = 6;
        }
      }
      pos++;
    }
    return result;
  }
  function scanNext() {
    value = "";
    scanError = 0;
    tokenOffset = pos;
    lineStartOffset = lineNumber;
    prevTokenLineStartOffset = tokenLineStartOffset;
    if (pos >= len) {
      tokenOffset = len;
      return token = 17;
    }
    var code = text.charCodeAt(pos);
    if (isWhiteSpace(code)) {
      do {
        pos++;
        value += String.fromCharCode(code);
        code = text.charCodeAt(pos);
      } while (isWhiteSpace(code));
      return token = 15;
    }
    if (isLineBreak(code)) {
      pos++;
      value += String.fromCharCode(code);
      if (code === 13 && text.charCodeAt(pos) === 10) {
        pos++;
        value += "\n";
      }
      lineNumber++;
      tokenLineStartOffset = pos;
      return token = 14;
    }
    switch (code) {
      case 123:
        pos++;
        return token = 1;
      case 125:
        pos++;
        return token = 2;
      case 91:
        pos++;
        return token = 3;
      case 93:
        pos++;
        return token = 4;
      case 58:
        pos++;
        return token = 6;
      case 44:
        pos++;
        return token = 5;
      case 34:
        pos++;
        value = scanString();
        return token = 10;
      case 47:
        var start = pos - 1;
        if (text.charCodeAt(pos + 1) === 47) {
          pos += 2;
          while (pos < len) {
            if (isLineBreak(text.charCodeAt(pos))) {
              break;
            }
            pos++;
          }
          value = text.substring(start, pos);
          return token = 12;
        }
        if (text.charCodeAt(pos + 1) === 42) {
          pos += 2;
          var safeLength = len - 1;
          var commentClosed = false;
          while (pos < safeLength) {
            var ch = text.charCodeAt(pos);
            if (ch === 42 && text.charCodeAt(pos + 1) === 47) {
              pos += 2;
              commentClosed = true;
              break;
            }
            pos++;
            if (isLineBreak(ch)) {
              if (ch === 13 && text.charCodeAt(pos) === 10) {
                pos++;
              }
              lineNumber++;
              tokenLineStartOffset = pos;
            }
          }
          if (!commentClosed) {
            pos++;
            scanError = 1;
          }
          value = text.substring(start, pos);
          return token = 13;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
      case 45:
        value += String.fromCharCode(code);
        pos++;
        if (pos === len || !isDigit(text.charCodeAt(pos))) {
          return token = 16;
        }
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        value += scanNumber();
        return token = 11;
      default:
        while (pos < len && isUnknownContentCharacter(code)) {
          pos++;
          code = text.charCodeAt(pos);
        }
        if (tokenOffset !== pos) {
          value = text.substring(tokenOffset, pos);
          switch (value) {
            case "true":
              return token = 8;
            case "false":
              return token = 9;
            case "null":
              return token = 7;
          }
          return token = 16;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
    }
  }
  function isUnknownContentCharacter(code) {
    if (isWhiteSpace(code) || isLineBreak(code)) {
      return false;
    }
    switch (code) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  function scanNextNonTrivia() {
    var result;
    do {
      result = scanNext();
    } while (result >= 12 && result <= 15);
    return result;
  }
  return {
    setPosition,
    getPosition: function() {
      return pos;
    },
    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
    getToken: function() {
      return token;
    },
    getTokenValue: function() {
      return value;
    },
    getTokenOffset: function() {
      return tokenOffset;
    },
    getTokenLength: function() {
      return pos - tokenOffset;
    },
    getTokenStartLine: function() {
      return lineStartOffset;
    },
    getTokenStartCharacter: function() {
      return tokenOffset - prevTokenLineStartOffset;
    },
    getTokenError: function() {
      return scanError;
    }
  };
}
function isWhiteSpace(ch) {
  return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch === 5760 || ch >= 8192 && ch <= 8203 || ch === 8239 || ch === 8287 || ch === 12288 || ch === 65279;
}
function isLineBreak(ch) {
  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}

// node_modules/jsonc-parser/lib/esm/impl/parser.js
var ParseOptions;
(function(ParseOptions2) {
  ParseOptions2.DEFAULT = {
    allowTrailingComma: false
  };
})(ParseOptions || (ParseOptions = {}));
function parse(text, errors, options) {
  if (errors === void 0) {
    errors = [];
  }
  if (options === void 0) {
    options = ParseOptions.DEFAULT;
  }
  var currentProperty = null;
  var currentParent = [];
  var previousParents = [];
  function onValue(value) {
    if (Array.isArray(currentParent)) {
      currentParent.push(value);
    } else if (currentProperty !== null) {
      currentParent[currentProperty] = value;
    }
  }
  var visitor = {
    onObjectBegin: function() {
      var object = {};
      onValue(object);
      previousParents.push(currentParent);
      currentParent = object;
      currentProperty = null;
    },
    onObjectProperty: function(name) {
      currentProperty = name;
    },
    onObjectEnd: function() {
      currentParent = previousParents.pop();
    },
    onArrayBegin: function() {
      var array = [];
      onValue(array);
      previousParents.push(currentParent);
      currentParent = array;
      currentProperty = null;
    },
    onArrayEnd: function() {
      currentParent = previousParents.pop();
    },
    onLiteralValue: onValue,
    onError: function(error, offset, length) {
      errors.push({ error, offset, length });
    }
  };
  visit(text, visitor, options);
  return currentParent[0];
}
function visit(text, visitor, options) {
  if (options === void 0) {
    options = ParseOptions.DEFAULT;
  }
  var _scanner = createScanner(text, false);
  function toNoArgVisit(visitFunction) {
    return visitFunction ? function() {
      return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
    } : function() {
      return true;
    };
  }
  function toOneArgVisit(visitFunction) {
    return visitFunction ? function(arg) {
      return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
    } : function() {
      return true;
    };
  }
  var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
  var disallowComments = options && options.disallowComments;
  var allowTrailingComma = options && options.allowTrailingComma;
  function scanNext() {
    while (true) {
      var token = _scanner.scan();
      switch (_scanner.getTokenError()) {
        case 4:
          handleError(14);
          break;
        case 5:
          handleError(15);
          break;
        case 3:
          handleError(13);
          break;
        case 1:
          if (!disallowComments) {
            handleError(11);
          }
          break;
        case 2:
          handleError(12);
          break;
        case 6:
          handleError(16);
          break;
      }
      switch (token) {
        case 12:
        case 13:
          if (disallowComments) {
            handleError(10);
          } else {
            onComment();
          }
          break;
        case 16:
          handleError(1);
          break;
        case 15:
        case 14:
          break;
        default:
          return token;
      }
    }
  }
  function handleError(error, skipUntilAfter, skipUntil) {
    if (skipUntilAfter === void 0) {
      skipUntilAfter = [];
    }
    if (skipUntil === void 0) {
      skipUntil = [];
    }
    onError(error);
    if (skipUntilAfter.length + skipUntil.length > 0) {
      var token = _scanner.getToken();
      while (token !== 17) {
        if (skipUntilAfter.indexOf(token) !== -1) {
          scanNext();
          break;
        } else if (skipUntil.indexOf(token) !== -1) {
          break;
        }
        token = scanNext();
      }
    }
  }
  function parseString(isValue) {
    var value = _scanner.getTokenValue();
    if (isValue) {
      onLiteralValue(value);
    } else {
      onObjectProperty(value);
    }
    scanNext();
    return true;
  }
  function parseLiteral() {
    switch (_scanner.getToken()) {
      case 11:
        var tokenValue = _scanner.getTokenValue();
        var value = Number(tokenValue);
        if (isNaN(value)) {
          handleError(2);
          value = 0;
        }
        onLiteralValue(value);
        break;
      case 7:
        onLiteralValue(null);
        break;
      case 8:
        onLiteralValue(true);
        break;
      case 9:
        onLiteralValue(false);
        break;
      default:
        return false;
    }
    scanNext();
    return true;
  }
  function parseProperty() {
    if (_scanner.getToken() !== 10) {
      handleError(3, [], [2, 5]);
      return false;
    }
    parseString(false);
    if (_scanner.getToken() === 6) {
      onSeparator(":");
      scanNext();
      if (!parseValue()) {
        handleError(4, [], [2, 5]);
      }
    } else {
      handleError(5, [], [2, 5]);
    }
    return true;
  }
  function parseObject() {
    onObjectBegin();
    scanNext();
    var needsComma = false;
    while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 2 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseProperty()) {
        handleError(4, [], [2, 5]);
      }
      needsComma = true;
    }
    onObjectEnd();
    if (_scanner.getToken() !== 2) {
      handleError(7, [2], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseArray() {
    onArrayBegin();
    scanNext();
    var needsComma = false;
    while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 4 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseValue()) {
        handleError(4, [], [4, 5]);
      }
      needsComma = true;
    }
    onArrayEnd();
    if (_scanner.getToken() !== 4) {
      handleError(8, [4], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseValue() {
    switch (_scanner.getToken()) {
      case 3:
        return parseArray();
      case 1:
        return parseObject();
      case 10:
        return parseString(true);
      default:
        return parseLiteral();
    }
  }
  scanNext();
  if (_scanner.getToken() === 17) {
    if (options.allowEmptyContent) {
      return true;
    }
    handleError(4, [], []);
    return false;
  }
  if (!parseValue()) {
    handleError(4, [], []);
    return false;
  }
  if (_scanner.getToken() !== 17) {
    handleError(9, [], []);
  }
  return true;
}

// node_modules/jsonc-parser/lib/esm/main.js
var parse2 = parse;

// src/textmateProvider.ts
var import_path4 = __toESM(require("path"));
var TextmateProvider = class extends BaseProvider {
  constructor(channel, config, subscriptions) {
    super(config, channel);
    this.config = config;
    this.subscriptions = subscriptions;
    this.loadedFiles = /* @__PURE__ */ new Set();
    this.loadedSnippets = [];
    this.loadedLanguageIds = /* @__PURE__ */ new Set();
    this.definitions = /* @__PURE__ */ new Map();
    this.loadedRoots = /* @__PURE__ */ new Set();
  }
  async init() {
    if (this.config.loadFromExtensions) {
      for (let extension of import_coc7.extensions.all) {
        await this.loadSnippetDefinition(extension);
      }
      import_coc7.extensions.onDidLoadExtension((extension) => {
        this.loadSnippetDefinition(extension).then((items) => {
          if (items == null ? void 0 : items.length) {
            items = items.filter((o) => o.languageIds.some((id) => import_coc7.workspace.languageIds.has(id)));
            this.loadSnippetsFromDefinition(extension.id, items);
          }
        }, (e) => {
          this.error(`Error on load textmate snippets: ${e.message}`, e.stack);
        });
      }, null, this.subscriptions);
      import_coc7.extensions.onDidUnloadExtension((id) => {
        this.loadedSnippets = this.loadedSnippets.filter((item) => {
          return item.extensionId !== id;
        });
      }, null, this.subscriptions);
    }
    let paths = this.config.snippetsRoots;
    for (let dir of paths != null ? paths : []) {
      await this.loadDefinitionFromRoot(dir);
    }
    for (let languageId of import_coc7.workspace.languageIds) {
      await this.loadByLanguageId(languageId);
    }
    import_coc7.workspace.onDidOpenTextDocument((e) => {
      this.loadByLanguageId(e.languageId);
    }, null, this.subscriptions);
    if (this.config.projectSnippets) {
      import_coc7.workspace.workspaceFolders.forEach((folder) => {
        let fsPath = import_coc7.Uri.parse(folder.uri).fsPath;
        void this.loadFromWorkspace(fsPath);
      });
      import_coc7.workspace.onDidChangeWorkspaceFolders((e) => {
        e.removed.forEach((folder) => {
          let fsPath = import_coc7.Uri.parse(folder.uri).fsPath;
          this.loadedSnippets = this.loadedSnippets.filter((o) => {
            return !o.filepath.startsWith(fsPath + import_path4.default.sep);
          });
        });
        e.added.forEach((folder) => {
          let fsPath = import_coc7.Uri.parse(folder.uri).fsPath;
          void this.loadFromWorkspace(fsPath);
        });
      });
    }
  }
  async loadFromWorkspace(fsPath) {
    let root = import_path4.default.join(fsPath, ".vscode");
    await this.loadDefinitionFromRoot(root);
  }
  async loadByLanguageId(languageId) {
    if (this.loadedLanguageIds.has(languageId))
      return;
    let filetypes = this.getFiletypes(languageId);
    this.info(`Loading textmate snippets from filetypes: ${filetypes.join(", ")}`);
    for (let languageId2 of filetypes) {
      if (this.loadedLanguageIds.has(languageId2))
        continue;
      this.loadedLanguageIds.add(languageId2);
      for (let [extensionId, items] of this.definitions.entries()) {
        for (let item of items) {
          if (!item.languageIds.includes(languageId2))
            continue;
          await this.loadSnippetsFromFile(item.filepath, item.languageIds, extensionId);
        }
      }
    }
  }
  async getSnippetFiles(filetype) {
    let filetypes = this.getFiletypes(filetype);
    filetypes.push("all");
    let filepaths = [];
    for (let def of this.loadedSnippets) {
      if (filepaths.includes(def.filepath))
        continue;
      if (def.filetypes.some((ft) => filetypes.includes(ft))) {
        filepaths.push(def.filepath);
      }
    }
    return filepaths;
  }
  async getTriggerSnippets(document, position, autoTrigger) {
    var _a;
    if (autoTrigger)
      return [];
    let line = document.getline(position.line);
    line = line.slice(0, position.character);
    let snippets = await this.getSnippets(document.filetype);
    if (!snippets || !snippets.length)
      return [];
    let edits = [];
    for (let snip of snippets) {
      let { prefix } = snip;
      if (!line.endsWith(prefix))
        continue;
      let pre = line.slice(0, line.length - prefix.length);
      if (pre.length && /\w/.test(pre[pre.length - 1]))
        continue;
      edits.push({
        prefix,
        range: import_coc7.Range.create(position.line, position.character - prefix.length, position.line, position.character),
        newText: snip.body,
        location: snip.filepath,
        description: snip.description,
        priority: (_a = snip.priority) != null ? _a : -1
      });
    }
    return edits;
  }
  getSnippets(filetype) {
    let res = [];
    let filetypes = this.getFiletypes(filetype);
    filetypes.push("all");
    for (let def of this.loadedSnippets) {
      if (filetypes.some((ft) => def.filetypes.includes(ft))) {
        let languageId = def.filetypes.includes(filetype) ? filetype : def.filetypes.find((ft) => filetypes.includes(ft));
        res.push(...toSnippets(def, languageId));
      }
    }
    res.sort((a, b) => {
      if (a.filetype != b.filetype) {
        if (a.filetype == filetype || b.filetype == filetype) {
          return a.filetype == filetype ? -1 : 1;
        }
        if (a.filetype == "all" || b.filetype == "all") {
          return a.filetype == "all" ? 1 : -1;
        }
        if (a.priority != b.priority) {
          return b.priority - a.priority;
        }
        return 0;
      }
    });
    let filtered = [];
    for (let item of res) {
      if (!filtered.find((o) => o.prefix == item.prefix && o.description == item.description)) {
        filtered.push(item);
      }
    }
    return filtered;
  }
  async loadSnippetDefinition(extension) {
    let { packageJSON } = extension;
    const arr = [];
    if (packageJSON.contributes && packageJSON.contributes.snippets) {
      let { snippets } = packageJSON.contributes;
      const extensionId = extension.id;
      for (let item of snippets) {
        let p = import_path4.default.join(extension.extensionPath, item.path);
        let exists = arr.find((o) => o.filepath == p);
        let languages3 = Array.isArray(item.language) ? item.language : [item.language];
        if (exists) {
          languages3.forEach((s) => {
            if (!exists.languageIds.includes(s)) {
              exists.languageIds.push(s);
            }
          });
          continue;
        }
        if (import_fs3.default.existsSync(p))
          arr.push({ languageIds: languages3, filepath: p });
      }
      if (snippets && snippets.length) {
        this.definitions.set(extensionId, arr);
      }
    }
    return arr;
  }
  async loadDefinitionFromRoot(configPath) {
    var _a;
    let root = import_coc7.workspace.expand(configPath);
    let stat = await statAsync(root);
    if (!stat || !stat.isDirectory()) {
      this.error(`${configPath} not a valid directory.`);
      return;
    }
    root = normalizeFilePath(root);
    if (this.loadedRoots.has(root))
      return;
    this.loadedRoots.add(root);
    let files = await import_fs3.default.promises.readdir(root, "utf8");
    files = files.filter((f) => f.endsWith(".json") || f.endsWith(".code-snippets"));
    let items = (_a = this.definitions.get("")) != null ? _a : [];
    for (let file of files) {
      let filepath = import_path4.default.join(root, file);
      if (file.endsWith(".code-snippets")) {
        this.info(`Loading global snippets from: ${filepath}`);
        await this.loadSnippetsFromFile(filepath, void 0, void 0);
      } else {
        let basename = import_path4.default.basename(file, ".json");
        items.push({ languageIds: [basename], filepath });
      }
    }
    this.definitions.set("", items);
  }
  async loadSnippetsFromDefinition(extensionId, items) {
    for (let item of items) {
      if (!import_fs3.default.existsSync(item.filepath))
        continue;
      await this.loadSnippetsFromFile(item.filepath, item.languageIds, extensionId);
    }
  }
  async loadSnippetsFromFile(snippetFilePath, languageIds, extensionId) {
    if (this.isLoaded(snippetFilePath) || this.isIgnored(snippetFilePath))
      return;
    let contents;
    try {
      contents = await import_fs3.default.promises.readFile(snippetFilePath, "utf8");
    } catch (e) {
      this.error(`Error on readFile "${snippetFilePath}": ${e.message}`);
      return;
    }
    try {
      this.loadSnippetsFromText(snippetFilePath, extensionId, languageIds, contents);
    } catch (e) {
      this.error(`Error on load snippets from "${snippetFilePath}": ${e.message}`, e.stack);
    }
  }
  isLoaded(filepath) {
    for (let file of this.loadedFiles) {
      if (sameFile(file, filepath)) {
        return true;
      }
    }
    return false;
  }
  loadSnippetsFromText(filepath, extensionId, ids, contents) {
    let snippets = [];
    let commentLanguageId;
    let isGlobal = isGlobalSnippet(filepath);
    this.loadedFiles.add(filepath);
    try {
      let errors = [];
      let lines = contents.split(/\r?\n/);
      if (isGlobal)
        commentLanguageId = languageIdFromComments(lines);
      let snippetObject = parse2(contents, errors, { allowTrailingComma: true });
      if (errors.length)
        this.error(`Parse error of ${filepath}`, errors);
      if (snippetObject) {
        for (let key of Object.keys(snippetObject)) {
          let p = '"' + key + '"';
          let idx = lines.findIndex((line) => line.trim().startsWith(p));
          let lnum = idx == -1 ? 0 : idx;
          snippets.push(Object.assign({ lnum }, snippetObject[key]));
        }
      }
    } catch (ex) {
      this.error(`Error on parse "${filepath}": ${ex.message}`, ex.stack);
      return;
    }
    const normalizedSnippets = [];
    snippets.forEach((snip) => {
      if (!snip.prefix)
        return;
      let languageIds;
      if (ids && ids.length > 0) {
        languageIds = ids;
      } else if (isGlobal) {
        languageIds = snip.scope ? snip.scope.split(",") : void 0;
        if (!languageIds && commentLanguageId)
          languageIds = [commentLanguageId];
      }
      if (!languageIds && isGlobal)
        languageIds = ["all"];
      let obj = {
        prefixes: Array.isArray(snip.prefix) ? snip.prefix : [snip.prefix],
        filetypes: languageIds,
        extensionId,
        filepath,
        lnum: snip.lnum,
        body: typeof snip.body === "string" ? snip.body : snip.body.join("\n"),
        description: getDescription(snip.description),
        triggerKind: 2 /* WordBoundary */,
        priority: languageIds.includes("all") ? -60 : extensionId ? -2 : -1
      };
      normalizedSnippets.push(obj);
      this.trace(`Snippet:`, obj);
    });
    this.loadedSnippets.push(...normalizedSnippets);
    this.info(`Loaded ${normalizedSnippets.length} textmate snippets from ${filepath}`, ids);
  }
};
function getDescription(description) {
  if (typeof description === "string")
    return description;
  if (Array.isArray(description) && description.every((s) => typeof s === "string"))
    return description.join("\n");
  return void 0;
}
function toSnippets(def, languageId) {
  return def.prefixes.map((prefix) => {
    return Object.assign(omit(def, ["filetypes", "prefixes"]), {
      prefix,
      filetype: languageId
    });
  });
}
function isGlobalSnippet(filepath) {
  return filepath.endsWith(".code-snippets");
}

// src/ultisnipsProvider.ts
var import_coc8 = require("coc.nvim");
var import_fs5 = __toESM(require("fs"));
var import_os3 = __toESM(require("os"));
var import_path5 = __toESM(require("path"));
var import_util7 = __toESM(require("util"));

// src/ultisnipsParser.ts
var import_fs4 = __toESM(require("fs"));
var import_readline2 = __toESM(require("readline"));
function fixFiletype(filetype) {
  if (filetype === "javascript_react")
    return "javascriptreact";
  return filetype;
}
var actionMap = {
  "pre_expand": "preExpand",
  "post_expand": "postExpand",
  "post_jump": "postJump"
};
var UltiSnipsParser = class {
  constructor(channel, trace = false) {
    this.channel = channel;
    this.trace = trace;
  }
  parseUltisnipsFile(filetype, filepath) {
    const rl = import_readline2.default.createInterface({
      input: import_fs4.default.createReadStream(filepath, "utf8"),
      crlfDelay: Infinity
    });
    let actions = [];
    let pycodes = [];
    let snippets = [];
    let block;
    let preLines = [];
    let first;
    let priority = 0;
    let lnum = 0;
    let clearsnippets = null;
    let parsedContext = null;
    let extendFiletypes = [];
    rl.on("line", (line) => {
      lnum += 1;
      if (!block && (line.startsWith("#") || line.length == 0))
        return;
      const [head, tail] = headTail(line);
      if (!block) {
        switch (head) {
          case "priority":
            let n = parseInt(tail.trim(), 10);
            if (!isNaN(n))
              priority = n;
            break;
          case "extends":
            let fts = tail.trim().split(/,\s+/);
            for (let ft of fts) {
              ft = fixFiletype(ft);
              if (extendFiletypes.indexOf(ft) == -1) {
                extendFiletypes.push(ft);
              }
            }
            break;
          case "pre_expand":
          case "post_expand":
          case "post_jump":
            actions.push(line);
            break;
          case "clearsnippets":
            clearsnippets = priority;
            break;
          case "context":
            parsedContext = tail.replace(/^"(.+)"$/, "$1");
            break;
          case "snippet":
          case "global":
            block = head;
            first = tail;
            break;
        }
        return;
      }
      if (head == "endglobal" && block == "global") {
        block = null;
        pycodes.push(...preLines);
        preLines = [];
        return;
      }
      if (head == "endsnippet" && block == "snippet") {
        block = null;
        try {
          let body = preLines.join("\n");
          let ms = first.match(/^(.+?)(?:\s+(?:"(.*?)")?(?:\s+"(.*?)")?(?:\s+(\w+))?)?\s*$/);
          let option = ms[4] || "";
          let trigger = getTriggerText(ms[1], option.includes("r"));
          let regex2 = null;
          let originRegex;
          let triggers = [];
          if (option.indexOf("r") !== -1) {
            originRegex = trigger;
            let pattern = convertRegex(trigger);
            if (pattern.endsWith("$"))
              pattern = pattern.slice(0, -1);
            regex2 = new RegExp(`(?:${pattern})$`);
            let parsed = getRegexText(trigger);
            if (!parsed.includes("|")) {
              triggers.push(parsed);
            } else {
              triggers = parsed.split(/\|/);
            }
          } else {
            triggers.push(trigger);
          }
          for (let prefix of triggers) {
            let ms2 = prefix.match(/^\W+/);
            let snippet = {
              originRegex,
              context: parsedContext ? parsedContext : option.includes("e") ? ms2[3] : void 0,
              filepath,
              filetype,
              prefix,
              special: ms2 == null ? void 0 : ms2[0],
              autoTrigger: option.indexOf("A") !== -1,
              lnum: lnum - preLines.length - 2,
              triggerKind: getTriggerKind(option),
              description: ms2 == null ? "" : ms2[2],
              regex: regex2,
              body,
              priority
            };
            while (actions.length) {
              const line2 = actions.pop();
              const [head2, tail2] = headTail(line2);
              snippet[actionMap[head2]] = trimQuote(tail2);
            }
            this.debug(`Loaded snippet`, snippet);
            snippets.push(snippet);
          }
        } catch (e) {
          this.error(`Create snippet error on: ${filepath}:${lnum - preLines.length - 1} ${e.message}`);
        } finally {
          parsedContext = null;
          preLines = [];
        }
      }
      if (block == "snippet" || block == "global") {
        preLines.push(line);
        return;
      }
    });
    return new Promise((resolve) => {
      rl.on("close", async () => {
        resolve({ snippets, clearsnippets, pythonCode: pycodes.join("\n"), extendFiletypes });
      });
    });
  }
  error(str) {
    if (!this.channel)
      return;
    this.channel.appendLine(`[Error ${new Date().toLocaleTimeString()}] ${str}`);
  }
  debug(str, data) {
    if (!this.channel || !this.trace)
      return;
    this.channel.appendLine(`[Debug ${new Date().toLocaleTimeString()}] ${str}: ${JSON.stringify(data, null, 2)}`);
  }
};
function getTriggerKind(option) {
  if (option.indexOf("i") !== -1 || option === "r") {
    return 3 /* InWord */;
  }
  if (option.indexOf("w") !== -1) {
    return 2 /* WordBoundary */;
  }
  if (option.indexOf("b") !== -1) {
    return 1 /* LineBegin */;
  }
  return 0 /* SpaceBefore */;
}

// src/ultisnipsProvider.ts
var pythonCodes = /* @__PURE__ */ new Map();
var UltiSnippetsProvider = class extends BaseProvider {
  constructor(channel, config, context) {
    super(config, channel);
    this.config = config;
    this.context = context;
    this.snippetFiles = [];
    this.fileItems = [];
    this.pythonSupport = true;
    import_coc8.workspace.onDidSaveTextDocument(async (doc) => {
      let uri = import_coc8.Uri.parse(doc.uri);
      if (uri.scheme != "file" || !doc.uri.endsWith(".snippets"))
        return;
      let filepath = uri.fsPath;
      if (!import_fs5.default.existsSync(filepath))
        return;
      let idx = this.snippetFiles.findIndex((s) => sameFile(s.filepath, filepath));
      if (idx !== -1) {
        const snippetFile = this.snippetFiles[idx];
        this.snippetFiles.splice(idx, 1);
        await this.loadSnippetsFromFile({ filetype: snippetFile.filetype, filepath, directory: snippetFile.directory });
      } else {
        let filetype = filetypeFromBasename(import_path5.default.basename(filepath, ".snippets"));
        await this.loadSnippetsFromFile({ filetype, filepath, directory: import_path5.default.dirname(filepath) });
      }
    }, null, this.context.subscriptions);
  }
  get directories() {
    let dirs = this.config.directories || [];
    return dirs.map((dir) => import_coc8.workspace.expand(dir));
  }
  async showPrompt() {
    let name = import_coc8.workspace.isVim ? `python` : `provider-python`;
    await import_coc8.window.showWarningMessage(`The Ultisnips feature of coc-snippets requires Python support on Vim, see :h ${name}`, {
      title: "I understand, don't show this message again",
      isCloseAffordance: true
    });
    let config = import_coc8.workspace.getConfiguration("snippets.ultisnips", null);
    config.update("pythonPrompt", false, true);
  }
  async init() {
    let { nvim, env } = import_coc8.workspace;
    this.info(`Using ultisnips directories:`, this.directories);
    try {
      await nvim.call("pyxeval", ["1"]);
    } catch (e) {
      this.pythonSupport = false;
      if (this.config.pythonPrompt) {
        void this.showPrompt();
      }
    }
    this.parser = new UltiSnipsParser(this.channel, this.config.trace);
    this.fileItems = await this.loadAllFilItems(env.runtimepath);
    import_coc8.workspace.onDidRuntimePathChange(async (e) => {
      let subFolders = await this.getSubFolders();
      const newItems = [];
      for (const dir of e) {
        let res = await this.getFilesFromDirectory(dir, subFolders);
        if (res == null ? void 0 : res.length)
          newItems.push(...res);
      }
      if (newItems.length) {
        this.fileItems.push(...newItems);
        const items2 = this.getValidItems(newItems);
        if (items2.length)
          await this.loadFromItems(items2);
      }
    }, null, this.context.subscriptions);
    if (this.pythonSupport) {
      let filepath = this.context.asAbsolutePath("python/ultisnips.py");
      await import_coc8.workspace.nvim.command(`exe 'pyxfile '.fnameescape('${filepath}')`);
    }
    const items = this.getValidItems(this.fileItems);
    if (items.length)
      await this.loadFromItems(items);
    import_coc8.workspace.onDidOpenTextDocument(async (e) => {
      let doc = import_coc8.workspace.getDocument(e.bufnr);
      if (doc)
        await this.loadByFiletype(doc.filetype);
    }, null, this.context.subscriptions);
  }
  async loadByFiletype(filetype) {
    let items = this.getFileItems(filetype);
    if (items.length)
      await this.loadFromItems(items);
  }
  getFileItems(filetype) {
    let filetypes = this.getFiletypes(filetype);
    filetypes.push("all");
    return this.fileItems.filter((o) => filetypes.includes(o.filetype));
  }
  get allFiletypes() {
    let filetypes = Array.from(import_coc8.workspace.filetypes);
    let res = [];
    for (let ft of filetypes) {
      let arr = this.getFiletypes(ft);
      arr.forEach((val) => {
        if (!res.includes(val))
          res.push(val);
      });
    }
    res.push("all");
    return res;
  }
  getValidItems(fileItems) {
    let filetypes = this.allFiletypes;
    return fileItems.filter((o) => filetypes.includes(o.filetype));
  }
  async loadFromItems(items) {
    if (items.length) {
      await Promise.all(items.map((item) => {
        return this.loadSnippetsFromFile(item);
      }));
      let pythonCode = "";
      for (let [file, code] of pythonCodes.entries()) {
        if (code)
          pythonCode += `# ${file}
` + code + "\n";
      }
      if (pythonCode) {
        pythonCodes.clear();
        await this.executePythonCode(pythonCode);
      }
    }
  }
  async loadSnippetsFromFile(fileItem) {
    let { filepath, directory, filetype } = fileItem;
    let idx = this.snippetFiles.findIndex((o) => sameFile(o.filepath, filepath));
    if (idx !== -1)
      return;
    if (this.isIgnored(filepath))
      return;
    idx = this.fileItems.findIndex((o) => o.filepath == filepath);
    if (idx !== -1)
      this.fileItems.splice(idx, 1);
    let { snippets, pythonCode, extendFiletypes, clearsnippets } = await this.parser.parseUltisnipsFile(filetype, filepath);
    if (!this.pythonSupport) {
      snippets = snippets.filter((s) => s.regex == null && s.context == null && s.body.indexOf("`!p") === -1);
    }
    this.snippetFiles.push({
      extendFiletypes,
      clearsnippets,
      directory,
      filepath,
      filetype,
      snippets
    });
    if (extendFiletypes == null ? void 0 : extendFiletypes.length) {
      let filetypes = this.config.extends[filetype] || [];
      filetypes = filetypes.concat(extendFiletypes);
      this.config.extends[filetype] = distinct(filetypes);
      let fts = [];
      for (let ft of extendFiletypes) {
        let filetypes2 = this.getFiletypes(ft);
        filetypes2.forEach((s) => {
          if (!fts.includes(s))
            fts.push(s);
        });
      }
      let items = this.fileItems.filter((o) => fts.includes(o.filetype));
      await Promise.all(items.map((item) => {
        return this.loadSnippetsFromFile(item);
      }));
    }
    this.info(`Loaded ${snippets.length} UltiSnip snippets from: ${filepath}`);
    if (pythonCode)
      pythonCodes.set(filepath, pythonCode);
  }
  async checkContext(context) {
    if (!this.pythonSupport)
      return false;
    let pyCodes = [
      "import re, os, vim, string, random",
      'if "snip" in globals():',
      "  __snip = snip",
      "snip = ContextSnippet()",
      `context = ${context}`,
      'if "__snip" in globals():',
      "  snip = __snip"
    ];
    await this.executePyCodes(pyCodes);
    return await import_coc8.workspace.nvim.call(`pyxeval`, "True if context else False");
  }
  async executePyCodes(lines) {
    try {
      await import_coc8.workspace.nvim.command(`pyx ${addPythonTryCatch(lines.join("\n"))}`);
    } catch (e) {
      let err = new Error(e.message);
      err.stack = `Error on execute python code:
${lines}
` + e.stack;
      throw err;
    }
  }
  async getTriggerSnippets(document, position, autoTrigger) {
    let snippets = this.getSnippets(document.filetype);
    let line = document.getline(position.line);
    line = line.slice(0, position.character);
    if (line.length == 0)
      return [];
    snippets = snippets.filter((s) => {
      if (autoTrigger && !s.autoTrigger)
        return false;
      let match = getMatched2(s, line);
      if (match == null)
        return false;
      if (s.triggerKind == 3 /* InWord */)
        return true;
      let pre = line.slice(0, line.length - match.length);
      if (s.triggerKind == 1 /* LineBegin */)
        return pre.trim() == "";
      if (s.triggerKind == 0 /* SpaceBefore */)
        return pre.length == 0 || /\s$/.test(pre);
      if (s.triggerKind == 2 /* WordBoundary */)
        return pre.length == 0 || !document.isWord(pre[pre.length - 1]);
      return false;
    });
    snippets.sort((a, b) => {
      if (a.context && !b.context)
        return -1;
      if (b.context && !a.context)
        return 1;
      return 0;
    });
    let edits = [];
    let hasContext = false;
    for (let s of snippets) {
      let character;
      if (s.context) {
        let valid = await this.checkContext(s.context);
        if (!valid)
          continue;
        hasContext = true;
      } else if (hasContext) {
        break;
      }
      if (s.regex == null) {
        character = position.character - s.prefix.length;
      } else {
        let len = line.match(s.regex)[0].length;
        character = position.character - len;
      }
      let range = import_coc8.Range.create(position.line, character, position.line, position.character);
      edits.push({
        range,
        newText: s.body,
        prefix: s.prefix,
        description: s.description,
        location: s.filepath,
        priority: s.priority,
        regex: s.originRegex,
        context: s.context
      });
    }
    return edits;
  }
  async getSnippetFiles(filetype) {
    let filetypes = this.getFiletypes(filetype);
    filetypes.push("all");
    let res = [];
    for (let s of this.snippetFiles) {
      if (filetypes.includes(s.filetype)) {
        res.push(s.filepath);
      }
    }
    return res;
  }
  getSnippets(filetype) {
    let filetypes = this.getFiletypes(filetype);
    filetypes.push("all");
    let snippetFiles = this.snippetFiles.filter((o) => filetypes.indexOf(o.filetype) !== -1);
    let min = null;
    let result = [];
    snippetFiles.sort((a, b) => {
      if (a.filetype == b.filetype)
        return 1;
      if (a.filetype == filetype)
        return -1;
      return 1;
    });
    for (let file of snippetFiles) {
      let { snippets, clearsnippets } = file;
      if (typeof clearsnippets == "number") {
        min = min ? Math.max(min, clearsnippets) : clearsnippets;
      }
      for (let snip of snippets) {
        if (snip.regex || snip.context) {
          result.push(snip);
        } else {
          let idx = result.findIndex((o) => o.prefix == snip.prefix && o.triggerKind == snip.triggerKind);
          if (idx == -1) {
            result.push(snip);
          } else {
            let item = result[idx];
            if (snip.priority > item.priority) {
              result[idx] = item;
            }
          }
        }
      }
    }
    if (min != null)
      result = result.filter((o) => o.priority >= min);
    result.sort((a, b) => {
      if (a.context && !b.context)
        return -1;
      if (b.context && !a.context)
        return 1;
      return 0;
    });
    return result;
  }
  async loadAllFilItems(runtimepath) {
    let { directories } = this;
    let res = [];
    for (let directory of directories) {
      if (import_path5.default.isAbsolute(directory)) {
        let items = await this.getSnippetFileItems(directory);
        res.push(...items);
      }
    }
    let subFolders = await this.getSubFolders();
    let rtps = runtimepath.split(",");
    for (let rtp of rtps) {
      let items = await this.getFilesFromDirectory(rtp, subFolders);
      res.push(...items);
    }
    return res;
  }
  async getSubFolders() {
    let { directories } = this;
    directories = directories.filter((s) => !import_path5.default.isAbsolute(s));
    let dirs = await import_coc8.workspace.nvim.eval('get(g:, "UltiSnipsSnippetDirectories", [])');
    for (let dir of dirs) {
      if (directories.indexOf(dir) == -1) {
        directories.push(dir);
      }
    }
    return directories;
  }
  async editSnippets(text) {
    const configuration = import_coc8.workspace.getConfiguration("snippets");
    const snippetsDir = await getSnippetsDirectory(configuration);
    let { nvim } = import_coc8.workspace;
    let buf = await nvim.buffer;
    let doc = import_coc8.workspace.getDocument(buf.id);
    if (!doc) {
      import_coc8.window.showMessage("Document not found", "error");
      return;
    }
    let filetype = doc.filetype ? doc.filetype : "all";
    filetype = filetype.indexOf(".") == -1 ? filetype : filetype.split(".")[0];
    let file = import_path5.default.join(snippetsDir, `${filetype}.snippets`);
    if (!import_fs5.default.existsSync(file)) {
      await import_util7.default.promisify(import_fs5.default.writeFile)(file, documentation, "utf8");
    }
    let uri = import_coc8.Uri.file(file).toString();
    await import_coc8.workspace.jumpTo(uri, null, configuration.get("editSnippetsCommand"));
    if (text) {
      await nvim.command("normal! G");
      await nvim.command("normal! 2o");
      let position = await import_coc8.window.getCursorPosition();
      let indent = text.match(/^\s*/)[0];
      text = text.split(/\r?\n/).map((s) => s.startsWith(indent) ? s.slice(indent.length) : s).join("\n");
      let escaped = text.replace(/([$}\]])/g, "\\$1");
      let snippet = 'snippet ${1:Tab_trigger} "${2:Description}" ${3:b}\n' + escaped + "\nendsnippet";
      let edit = import_coc8.TextEdit.insert(position, snippet);
      await import_coc8.commands.executeCommand("editor.action.insertSnippet", edit, false);
    }
  }
  async getFilesFromDirectory(directory, subFolders) {
    let res = [];
    for (let folder of subFolders) {
      let items = await this.getSnippetFileItems(import_path5.default.join(directory, folder));
      res.push(...items);
    }
    return res;
  }
  async getSnippetFileItems(directory) {
    let res = [];
    let stat = await statAsync(directory);
    if (stat && stat.isDirectory()) {
      let files = await readdirAsync(directory);
      if (files.length) {
        for (let f of files) {
          let file = import_path5.default.join(directory, f);
          if (file.endsWith(".snippets")) {
            let basename = import_path5.default.basename(f, ".snippets");
            let filetype = filetypeFromBasename(basename);
            res.push({ filepath: file, directory, filetype });
          } else {
            let stat2 = await statAsync(file);
            if (stat2 && stat2.isDirectory()) {
              let files2 = await readdirAsync(file);
              for (let filename of files2) {
                if (filename.endsWith(".snippets")) {
                  res.push({ filepath: import_path5.default.join(file, filename), directory, filetype: f });
                }
              }
            }
          }
        }
      }
    }
    return res;
  }
  async executePythonCode(pythonCode) {
    if (!this.pythonSupport)
      return;
    try {
      let tmpfile = import_path5.default.join(import_os3.default.tmpdir(), `coc-ultisnips-${uid()}.py`);
      let code = addPythonTryCatch(pythonCode);
      import_fs5.default.writeFileSync(tmpfile, "# -*- coding: utf-8 -*-\n" + code, "utf8");
      this.info(`Execute python code in: ${tmpfile}`);
      await import_coc8.workspace.nvim.command(`exe 'pyxfile '.fnameescape('${tmpfile}')`);
    } catch (e) {
      this.error(`Error on execute python script ${e.stack}:`, pythonCode);
      import_coc8.window.showMessage(`Error on execute python script: ${e.message}`, "error");
    }
  }
};
function filetypeFromBasename(basename) {
  if (basename == "typescript_react")
    return "typescriptreact";
  if (basename == "javascript_react")
    return "javascriptreact";
  if (basename.includes("_"))
    return basename.split("_", 2)[0];
  return basename.split("-", 2)[0];
}
function addPythonTryCatch(code) {
  if (!import_coc8.workspace.isVim)
    return code;
  let lines = [
    "import traceback, vim",
    `vim.vars['errmsg'] = ''`,
    "try:"
  ];
  lines.push(...code.split("\n").map((line) => "    " + line));
  lines.push("except Exception as e:");
  lines.push(`    vim.vars['errmsg'] = traceback.format_exc()`);
  return lines.join("\n");
}
function getMatched2(snippet, line) {
  let { prefix, regex: regex2 } = snippet;
  if (regex2) {
    let ms = line.match(regex2);
    if (!ms)
      return void 0;
    return ms[0];
  }
  if (!line.endsWith(prefix))
    return void 0;
  return prefix;
}
async function getSnippetsDirectory(configuration) {
  let snippetsDir = configuration.get("userSnippetsDirectory");
  if (snippetsDir) {
    snippetsDir = import_coc8.workspace.expand(snippetsDir);
    if (!import_path5.default.isAbsolute(snippetsDir)) {
      import_coc8.window.showMessage(`snippets.userSnippetsDirectory => ${snippetsDir} should be absolute path`, "warning");
      snippetsDir = null;
    }
  }
  if (!snippetsDir)
    snippetsDir = import_path5.default.join(import_path5.default.dirname(import_coc8.workspace.env.extensionRoot), "ultisnips");
  if (!import_fs5.default.existsSync(snippetsDir)) {
    await import_fs5.default.promises.mkdir(snippetsDir);
  }
  return snippetsDir;
}

// src/index.ts
async function insertSnippetEdit(edit) {
  let ultisnips = edit.source == "ultisnips" || edit.source == "snipmate";
  let option;
  if (ultisnips) {
    option = {
      regex: edit.regex,
      context: edit.context
    };
  }
  await import_coc9.commands.executeCommand("editor.action.insertSnippet", import_coc9.TextEdit.replace(edit.range, edit.newText), option);
}
function enableSnippetsFiletype(subscriptions) {
  let { nvim } = import_coc9.workspace;
  import_coc9.workspace.documents.forEach((doc) => {
    if (doc.uri.endsWith(".snippets")) {
      doc.buffer.setOption("filetype", "snippets", true);
    }
  });
  import_coc9.workspace.onDidOpenTextDocument(async (document) => {
    if (document.uri.endsWith(".snippets")) {
      let doc = import_coc9.workspace.getDocument(document.uri);
      if (!doc)
        return;
      let { buffer } = doc;
      await buffer.setOption("filetype", "snippets");
    }
  }, null, subscriptions);
  const rtp = import_coc9.workspace.env.runtimepath;
  let paths = rtp.split(",");
  let idx = paths.findIndex((s) => /^ultisnips$/i.test(import_path6.default.basename(s)));
  if (idx === -1) {
    let directory = import_path6.default.resolve(__dirname, "..");
    nvim.command("autocmd BufNewFile,BufRead *.snippets setf snippets", true);
    nvim.command(`execute 'noa set rtp+='.fnameescape('${directory.replace(/'/g, "''")}')`, true);
  }
}
async function snippetSelect() {
  let doc = await import_coc9.workspace.document;
  if (!doc)
    return;
  let { nvim } = import_coc9.workspace;
  let mode = await nvim.call("visualmode");
  if (["v", "V"].indexOf(mode) == -1) {
    import_coc9.window.showMessage(`visual mode ${mode} not supported`, "warning");
    return;
  }
  await nvim.command("normal! `<");
  let start = await import_coc9.window.getCursorPosition();
  await nvim.command("normal! `>");
  let end = await import_coc9.window.getCursorPosition();
  end = import_coc9.Position.create(end.line, end.character + 1);
  let range = import_coc9.Range.create(start, end);
  let text = doc.textDocument.getText(range);
  await nvim.call("feedkeys", ["i", "in"]);
  if (mode == "v") {
    await doc.applyEdits([{ range, newText: "" }]);
  } else {
    let currline = doc.getline(start.line);
    let indent = currline.match(/^\s*/)[0];
    let lines = text.split(/\r?\n/);
    lines = lines.map((s) => s.startsWith(indent) ? s.slice(indent.length) : s);
    text = lines.join("\n");
    range = import_coc9.Range.create(import_coc9.Position.create(start.line, indent.length), end);
    await doc.applyEdits([{ range, newText: "" }]);
  }
  await nvim.setVar("coc_selected_text", text);
  await import_coc9.window.moveTo(range.start);
}
async function activate(context) {
  var _a;
  let { subscriptions } = context;
  const { nvim } = import_coc9.workspace;
  const configuration = import_coc9.workspace.getConfiguration("snippets");
  const filetypeExtends = configuration.get("extends", {});
  const trace = configuration.get("trace", "error");
  const channel = import_coc9.window.createOutputChannel("snippets");
  subscriptions.push(channel);
  const manager = new ProviderManager(channel, subscriptions);
  enableSnippetsFiletype(subscriptions);
  let excludes = configuration.get("excludePatterns", []);
  if (!Array.isArray(excludes))
    excludes = [];
  excludes = excludes.map((p) => import_coc9.workspace.expand(p));
  if (configuration.get("ultisnips.enable", true)) {
    const snippetsDir = await getSnippetsDirectory(configuration);
    let config = configuration.get("ultisnips", {});
    let c = import_merge.default.recursive(true, config, {
      excludes,
      pythonPrompt: configuration.get("ultisnips.pythonPrompt", true),
      extends: import_merge.default.recursive(true, {}, filetypeExtends)
    });
    c.directories = c.directories ? c.directories.slice() : [];
    if (Array.isArray(c.directories) && snippetsDir && c.directories.findIndex((dir) => sameFile(dir, snippetsDir)) == -1) {
      c.directories.push(snippetsDir);
    }
    let provider = new UltiSnippetsProvider(channel, c, context);
    manager.regist(provider, "ultisnips");
    subscriptions.push(import_coc9.commands.registerCommand("snippets.editSnippets", provider.editSnippets));
  }
  if (configuration.loadFromExtensions || ((_a = configuration.textmateSnippetsRoots) == null ? void 0 : _a.length) > 0) {
    const config = {
      loadFromExtensions: configuration.get("loadFromExtensions", true),
      snippetsRoots: configuration.get("textmateSnippetsRoots", []),
      projectSnippets: configuration.get("loadVSCodeProjectSnippets", true),
      extends: import_merge.default.recursive(true, {}, filetypeExtends),
      trace: trace == "verbose",
      excludes
    };
    let provider = new TextmateProvider(channel, config, subscriptions);
    manager.regist(provider, "snippets");
  }
  if (configuration.get("snipmate.enable", true)) {
    let config = {
      author: configuration.get("snipmate.author", ""),
      extends: import_merge.default.recursive(true, {}, filetypeExtends),
      trace: configuration.get("snipmate.trace", false),
      excludes
    };
    let provider = new SnipmateProvider(channel, config, subscriptions);
    manager.regist(provider, "snipmate");
  }
  if (configuration.get("massCode.enable", false)) {
    let config = {
      host: configuration.get("massCode.host", "localhost"),
      port: configuration.get("massCode.port", 3033),
      extends: import_merge.default.recursive(true, {}, filetypeExtends),
      trace: configuration.get("massCode.trace", false),
      excludes
    };
    let provider = new MassCodeProvider(channel, config);
    manager.regist(provider, "massCode");
    subscriptions.push(import_coc9.commands.registerCommand("snippets.editMassCodeSnippets", provider.createSnippet.bind(provider)));
  }
  if (configuration.get("autoTrigger", true)) {
    import_coc9.events.on("TextInsert", async (bufnr, info) => {
      let changedtick = info.changedtick;
      let doc = import_coc9.workspace.getDocument(bufnr);
      if (!doc || doc.isCommandLine || !doc.attached)
        return;
      let res = await waitDocument(doc, changedtick);
      if (!res)
        return;
      changedtick = doc.changedtick;
      let position = import_coc9.Position.create(info.lnum - 1, info.pre.length);
      let edits = await manager.getTriggerSnippets(bufnr, true, position);
      if (doc.changedtick != changedtick)
        return;
      if (edits.length == 0)
        return;
      if (edits.length > 1) {
        channel.appendLine(`Multiple snippets found on auto trigger: ${JSON.stringify(edits, null, 2)}`);
        import_coc9.window.showMessage("Multiple snippets found on auto trigger", "warning");
        await import_coc9.commands.executeCommand("workspace.showOutput", "snippets");
      }
      await insertSnippetEdit(edits[0]);
    }, null, subscriptions);
  }
  manager.init().catch((e) => {
    channel.appendLine(`[Error ${new Date().toLocaleTimeString()}] Error on init: ${e.stack}`);
  });
  if (manager.hasProvider) {
    let disposable = import_coc9.languages.registerCompletionItemProvider("snippets", configuration.get("shortcut", "S"), null, manager, configuration.get("triggerCharacters", []), configuration.get("priority", 90));
    subscriptions.push(disposable);
  }
  async function fallback() {
    await nvim.call("coc#start", [{ source: "snippets" }]);
  }
  async function doExpand(bufnr) {
    let edits = await manager.getTriggerSnippets(bufnr);
    if (edits.length == 0)
      return false;
    if (edits.length == 1) {
      await insertSnippetEdit(edits[0]);
    } else {
      setTimeout(async () => {
        let idx = await import_coc9.window.showMenuPicker(edits.map((e) => e.description || e.prefix), { title: "choose snippet" });
        if (idx == -1)
          return;
        await insertSnippetEdit(edits[idx]);
      }, 10);
      return true;
    }
    return true;
  }
  subscriptions.push(import_coc9.workspace.registerKeymap(["x"], "convert-snippet", async () => {
    let mode = await import_coc9.workspace.nvim.call("visualmode");
    if (!mode)
      return;
    let doc = await import_coc9.workspace.document;
    if (!doc)
      return;
    let range = await import_coc9.window.getSelectedRange(mode);
    let text = doc.textDocument.getText(range);
    if (text)
      await import_coc9.commands.executeCommand("snippets.editSnippets", text);
  }, { sync: false }));
  subscriptions.push(import_coc9.commands.registerCommand("snippets.openOutput", () => {
    void import_coc9.window.showOutputChannel("snippets", false);
  }));
  subscriptions.push(import_coc9.commands.registerCommand("snippets.openSnippetFiles", async () => {
    let buf = await nvim.buffer;
    let doc = import_coc9.workspace.getDocument(buf.id);
    if (!doc) {
      import_coc9.window.showMessage("Document not found", "error");
      return;
    }
    let files = await manager.getSnippetFiles(doc.filetype);
    if (!files.length) {
      import_coc9.window.showMessage("No related snippet file found", "warning");
      return;
    }
    let idx = await import_coc9.window.showQuickpick(files, "choose snippet file:");
    if (idx == -1)
      return;
    let uri = import_coc9.Uri.file(files[idx]).toString();
    await import_coc9.workspace.jumpTo(uri, null, configuration.get("editSnippetsCommand"));
  }));
  subscriptions.push(import_coc9.workspace.registerKeymap(["i"], "snippets-expand", async () => {
    let bufnr = await nvim.eval('bufnr("%")');
    let expanded = await doExpand(bufnr);
    if (!expanded)
      await fallback();
  }, { silent: true, sync: true, cancel: true }));
  subscriptions.push(import_coc9.workspace.registerKeymap(["i"], "snippets-expand-jump", async () => {
    let bufnr = await nvim.eval('bufnr("%")');
    let expanded = await doExpand(bufnr);
    if (!expanded) {
      let session = import_coc9.snippetManager.getSession(bufnr);
      if (session && session.isActive) {
        await nvim.call("coc#_cancel", []);
        await import_coc9.snippetManager.nextPlaceholder();
        return;
      }
      await fallback();
    }
  }, { silent: true, sync: true, cancel: true }));
  subscriptions.push(import_coc9.workspace.registerKeymap(["v"], "snippets-select", snippetSelect, { silent: true, sync: false, cancel: true }));
  registerLanguageProvider(subscriptions, channel, configuration);
  subscriptions.push(import_coc9.listManager.registerList(new SnippetsList(import_coc9.workspace.nvim, manager)));
  return {
    expandable: async () => {
      let bufnr = await nvim.eval('bufnr("%")');
      let edits = await manager.getTriggerSnippets(bufnr);
      return edits && edits.length > 0;
    }
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate
});
//# sourceMappingURL=index.js.map
